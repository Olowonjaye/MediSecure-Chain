var W=Object.defineProperty;var L=t=>{throw TypeError(t)};var G=(t,e,r)=>e in t?W(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var P=(t,e,r)=>G(t,typeof e!="symbol"?e+"":e,r),z=(t,e,r)=>e.has(t)||L("Cannot "+r);var x=(t,e,r)=>(z(t,e,"read from private field"),r?r.call(t):e.get(t)),R=(t,e,r)=>e.has(t)?L("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,r),M=(t,e,r,n)=>(z(t,e,"write to private field"),n?n.call(t,r):e.set(t,r),r);import{n as getDefaultExportFromCjs,o as commonjsGlobal,a as reactExports,j as jsxRuntimeExports,h as hexlify,B as BrowserProvider,k as keccak256,t as toUtf8Bytes,b as registerResource}from"./index-nTQIyIYe.js";import{h as hospitalApi}from"./hospitalApi-BvT66DJ5.js";const LOAD_BASE=t=>Promise.reject(new Error(`No base found for "${t}"`));class Multibases{constructor(e){this._basesByName={},this._basesByPrefix={},this._loadBase=e.loadBase||LOAD_BASE;for(const r of e.bases)this.addBase(r)}addBase(e){if(this._basesByName[e.name]||this._basesByPrefix[e.prefix])throw new Error(`Codec already exists for codec "${e.name}"`);this._basesByName[e.name]=e,this._basesByPrefix[e.prefix]=e}removeBase(e){delete this._basesByName[e.name],delete this._basesByPrefix[e.prefix]}async getBase(e){if(this._basesByName[e])return this._basesByName[e];if(this._basesByPrefix[e])return this._basesByPrefix[e];const r=await this._loadBase(e);return this._basesByName[r.name]==null&&this._basesByPrefix[r.prefix]==null&&this.addBase(r),r}listBases(){return Object.values(this._basesByName)}}const LOAD_CODEC=t=>Promise.reject(new Error(`No codec found for "${t}"`));class Multicodecs{constructor(e){this._codecsByName={},this._codecsByCode={},this._loadCodec=e.loadCodec||LOAD_CODEC;for(const r of e.codecs)this.addCodec(r)}addCodec(e){if(this._codecsByName[e.name]||this._codecsByCode[e.code])throw new Error(`Resolver already exists for codec "${e.name}"`);this._codecsByName[e.name]=e,this._codecsByCode[e.code]=e}removeCodec(e){delete this._codecsByName[e.name],delete this._codecsByCode[e.code]}async getCodec(e){const r=typeof e=="string"?this._codecsByName:this._codecsByCode;if(r[e])return r[e];const n=await this._loadCodec(e);return r[e]==null&&this.addCodec(n),n}listCodecs(){return Object.values(this._codecsByName)}}const LOAD_HASHER=t=>Promise.reject(new Error(`No hasher found for "${t}"`));class Multihashes{constructor(e){this._hashersByName={},this._hashersByCode={},this._loadHasher=e.loadHasher||LOAD_HASHER;for(const r of e.hashers)this.addHasher(r)}addHasher(e){if(this._hashersByName[e.name]||this._hashersByCode[e.code])throw new Error(`Resolver already exists for codec "${e.name}"`);this._hashersByName[e.name]=e,this._hashersByCode[e.code]=e}removeHasher(e){delete this._hashersByName[e.name],delete this._hashersByCode[e.code]}async getHasher(e){const r=typeof e=="string"?this._hashersByName:this._hashersByCode;if(r[e])return r[e];const n=await this._loadHasher(e);return r[e]==null&&this.addHasher(n),n}listHashers(){return Object.values(this._hashersByName)}}var encode_1$6=encode$t,MSB$8=128,MSBALL$6=-128,INT$6=Math.pow(2,31);function encode$t(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT$6;)e[r++]=t&255|MSB$8,t/=128;for(;t&MSBALL$6;)e[r++]=t&255|MSB$8,t>>>=7;return e[r]=t|0,encode$t.bytes=r-n+1,e}var decode$F=read$6,MSB$1$6=128,REST$1$5=127;function read$6(t,n){var r=0,n=n||0,o=0,s=n,a,i=t.length;do{if(s>=i)throw read$6.bytes=0,new RangeError("Could not decode varint");a=t[s++],r+=o<28?(a&REST$1$5)<<o:(a&REST$1$5)*Math.pow(2,o),o+=7}while(a>=MSB$1$6);return read$6.bytes=s-n,r}var N1$7=Math.pow(2,7),N2$7=Math.pow(2,14),N3$7=Math.pow(2,21),N4$7=Math.pow(2,28),N5$7=Math.pow(2,35),N6$7=Math.pow(2,42),N7$7=Math.pow(2,49),N8$6=Math.pow(2,56),N9$6=Math.pow(2,63),length$6=function(t){return t<N1$7?1:t<N2$7?2:t<N3$7?3:t<N4$7?4:t<N5$7?5:t<N6$7?6:t<N7$7?7:t<N8$6?8:t<N9$6?9:10},varint$7={encode:encode_1$6,decode:decode$F,encodingLength:length$6},_brrp_varint$5=varint$7;const decode$E=(t,e=0)=>[_brrp_varint$5.decode(t,e),_brrp_varint$5.decode.bytes],encodeTo$5=(t,e,r=0)=>(_brrp_varint$5.encode(t,e,r),e),encodingLength$6=t=>_brrp_varint$5.encodingLength(t),equals$d=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},coerce$7=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},create$8=(t,e)=>{const r=e.byteLength,n=encodingLength$6(t),o=n+encodingLength$6(r),s=new Uint8Array(o+r);return encodeTo$5(t,s,0),encodeTo$5(r,s,n),s.set(e,o),new Digest$5(t,r,e,s)},decode$D=t=>{const e=coerce$7(t),[r,n]=decode$E(e),[o,s]=decode$E(e.subarray(n)),a=e.subarray(n+s);if(a.byteLength!==o)throw new Error("Incorrect length");return new Digest$5(r,o,a,e)},equals$c=(t,e)=>{if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&equals$d(t.bytes,r.bytes)}};let Digest$5=class{constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}};function base$7(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var s=t.charAt(o),a=s.charCodeAt(0);if(r[a]!==255)throw new TypeError(s+" is ambiguous");r[a]=o}var i=t.length,c=t.charAt(0),d=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var h=0,S=0,y=0,m=u.length;y!==m&&u[y]===0;)y++,h++;for(var $=(m-y)*l+1>>>0,b=new Uint8Array($);y!==m;){for(var w=u[y],T=0,g=$-1;(w!==0||T<S)&&g!==-1;g--,T++)w+=256*b[g]>>>0,b[g]=w%i>>>0,w=w/i>>>0;if(w!==0)throw new Error("Non-zero carry");S=T,y++}for(var E=$-S;E!==$&&b[E]===0;)E++;for(var C=c.repeat(h);E<$;++E)C+=t.charAt(b[E]);return C}function p(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var h=0;if(u[h]!==" "){for(var S=0,y=0;u[h]===c;)S++,h++;for(var m=(u.length-h)*d+1>>>0,$=new Uint8Array(m);u[h];){var b=r[u.charCodeAt(h)];if(b===255)return;for(var w=0,T=m-1;(b!==0||w<y)&&T!==-1;T--,w++)b+=i*$[T]>>>0,$[T]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");y=w,h++}if(u[h]!==" "){for(var g=m-y;g!==m&&$[g]===0;)g++;for(var E=new Uint8Array(S+(m-g)),C=S;g!==m;)E[C++]=$[g++];return E}}}function v(u){var h=p(u);if(h)return h;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:p,decode:v}}var src$8=base$7,_brrp__multiformats_scope_baseX$7=src$8;let Encoder$7=class{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Decoder$7=class{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$7(this,e)}},ComposedDecoder$7=class{constructor(e){this.decoders=e}or(e){return or$7(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$7=(t,e)=>new ComposedDecoder$7({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});let Codec$7=class{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$7(e,r,n),this.decoder=new Decoder$7(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const from$8=({name:t,prefix:e,encode:r,decode:n})=>new Codec$7(t,e,r,n),baseX$7=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$7(r,e);return from$8({prefix:t,name:e,encode:n,decode:s=>coerce$7(o(s))})},decode$C=(t,e,r,n)=>{const o={};for(let l=0;l<e.length;++l)o[e[l]]=l;let s=t.length;for(;t[s-1]==="=";)--s;const a=new Uint8Array(s*r/8|0);let i=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[t[l]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<r|f,i+=r,i>=8&&(i-=8,a[d++]=255&c>>i)}if(i>=r||255&c<<8-i)throw new SyntaxError("Unexpected end of data");return a},encode$s=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let s="",a=0,i=0;for(let c=0;c<t.length;++c)for(i=i<<8|t[c],a+=8;a>r;)a-=r,s+=e[o&i>>a];if(a&&(s+=e[o&i<<r-a]),n)for(;s.length*r&7;)s+="=";return s},rfc4648$7=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$8({prefix:e,name:t,encode(o){return encode$s(o,n,r)},decode(o){return decode$C(o,n,r,t)}}),base58btc$7=baseX$7({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});baseX$7({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});const base32$b=rfc4648$7({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});rfc4648$7({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});rfc4648$7({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});rfc4648$7({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});rfc4648$7({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});rfc4648$7({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});rfc4648$7({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});rfc4648$7({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});rfc4648$7({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const format$9=(t,e)=>{const{bytes:r,version:n}=t;switch(n){case 0:return toStringV0$5(r,baseCache$5(t),e||base58btc$7.encoder);default:return toStringV1$5(r,baseCache$5(t),e||base32$b.encoder)}},cache$5=new WeakMap,baseCache$5=t=>{const e=cache$5.get(t);if(e==null){const r=new Map;return cache$5.set(t,r),r}return e};let CID$5=class A{constructor(e,r,n,o){this.code=r,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE$5)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE$5)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return A.createV0(r)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create$8(e,r);return A.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return A.equals(this,e)}static equals(e,r){const n=r;return n&&e.code===n.code&&e.version===n.version&&equals$c(e.multihash,n.multihash)}toString(e){return format$9(this,e)}toJSON(){return{"/":format$9(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const r=e;if(r instanceof A)return r;if(r["/"]!=null&&r["/"]===r.bytes||r.asCID===r){const{version:n,code:o,multihash:s,bytes:a}=r;return new A(n,o,s,a||encodeCID$6(n,o,s.bytes))}else if(r[cidSymbol$5]===!0){const{version:n,multihash:o,code:s}=r,a=decode$D(o);return A.create(n,s,a)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(r!==DAG_PB_CODE$5)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$5}) block encoding`);return new A(e,r,n,n.bytes)}case 1:{const o=encodeCID$6(e,r,n.bytes);return new A(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return A.create(0,DAG_PB_CODE$5,e)}static createV1(e,r){return A.create(1,e,r)}static decode(e){const[r,n]=A.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=A.inspectBytes(e),n=r.size-r.multihashSize,o=coerce$7(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");const s=o.subarray(r.multihashSize-r.digestSize),a=new Digest$5(r.multihashCode,r.digestSize,s,o);return[r.version===0?A.createV0(a):A.createV1(r.codec,a),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[f,p]=decode$E(e.subarray(r));return r+=p,f};let o=n(),s=DAG_PB_CODE$5;if(o===18?(o=0,r=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const a=r,i=n(),c=n(),d=r+c,l=d-a;return{version:o,codec:s,multihashCode:i,digestSize:c,multihashSize:l,size:d}}static parse(e,r){const[n,o]=parseCIDtoBytes$5(e,r),s=A.decode(o);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return baseCache$5(s).set(n,e),s}};const parseCIDtoBytes$5=(t,e)=>{switch(t[0]){case"Q":{const r=e||base58btc$7;return[base58btc$7.prefix,r.decode(`${base58btc$7.prefix}${t}`)]}case base58btc$7.prefix:{const r=e||base58btc$7;return[base58btc$7.prefix,r.decode(t)]}case base32$b.prefix:{const r=e||base32$b;return[base32$b.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},toStringV0$5=(t,e,r)=>{const{prefix:n}=r;if(n!==base58btc$7.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=e.get(n);if(o==null){const s=r.encode(t).slice(1);return e.set(n,s),s}else return o},toStringV1$5=(t,e,r)=>{const{prefix:n}=r,o=e.get(n);if(o==null){const s=r.encode(t);return e.set(n,s),s}else return o},DAG_PB_CODE$5=112,SHA_256_CODE$5=18,encodeCID$6=(t,e,r)=>{const n=encodingLength$6(t),o=n+encodingLength$6(e),s=new Uint8Array(o+r.byteLength);return encodeTo$5(t,s,0),encodeTo$5(e,s,n),s.set(r,o),s},cidSymbol$5=Symbol.for("@ipld/js-cid/CID"),textDecoder$2=new TextDecoder;function decodeVarint(t,e){let r=0;for(let n=0;;n+=7){if(n>=64)throw new Error("protobuf: varint overflow");if(e>=t.length)throw new Error("protobuf: unexpected end of data");const o=t[e++];if(r+=n<28?(o&127)<<n:(o&127)*2**n,o<128)break}return[r,e]}function decodeBytes(t,e){let r;[r,e]=decodeVarint(t,e);const n=e+r;if(r<0||n<0)throw new Error("protobuf: invalid length");if(n>t.length)throw new Error("protobuf: unexpected end of data");return[t.subarray(e,n),n]}function decodeKey(t,e){let r;return[r,e]=decodeVarint(t,e),[r&7,r>>3,e]}function decodeLink(t){const e={},r=t.length;let n=0;for(;n<r;){let o,s;if([o,s,n]=decodeKey(t,n),s===1){if(e.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(o!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Hash`);if(e.Name!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[e.Hash,n]=decodeBytes(t,n)}else if(s===2){if(e.Name!==void 0)throw new Error("protobuf: (PBLink) duplicate Name section");if(o!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Name`);if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let a;[a,n]=decodeBytes(t,n),e.Name=textDecoder$2.decode(a)}else if(s===3){if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(o!==0)throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Tsize`);[e.Tsize,n]=decodeVarint(t,n)}else throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${s}`)}if(n>r)throw new Error("protobuf: (PBLink) unexpected end of data");return e}function decodeNode(t){const e=t.length;let r=0,n,o=!1,s;for(;r<e;){let i,c;if([i,c,r]=decodeKey(t,r),i!==2)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${i}`);if(c===1){if(s)throw new Error("protobuf: (PBNode) duplicate Data section");[s,r]=decodeBytes(t,r),n&&(o=!0)}else if(c===2){if(o)throw new Error("protobuf: (PBNode) duplicate Links section");n||(n=[]);let d;[d,r]=decodeBytes(t,r),n.push(decodeLink(d))}else throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${c}`)}if(r>e)throw new Error("protobuf: (PBNode) unexpected end of data");const a={};return s&&(a.Data=s),a.Links=n||[],a}const textEncoder$3=new TextEncoder,maxInt32=2**32,maxUInt32=2**31;function encodeLink(t,e){let r=e.length;if(typeof t.Tsize=="number"){if(t.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(t.Tsize))throw new Error("Tsize too large for encoding");r=encodeVarint(e,r,t.Tsize)-1,e[r]=24}if(typeof t.Name=="string"){const n=textEncoder$3.encode(t.Name);r-=n.length,e.set(n,r),r=encodeVarint(e,r,n.length)-1,e[r]=18}return t.Hash&&(r-=t.Hash.length,e.set(t.Hash,r),r=encodeVarint(e,r,t.Hash.length)-1,e[r]=10),e.length-r}function encodeNode(t){const e=sizeNode(t),r=new Uint8Array(e);let n=e;if(t.Data&&(n-=t.Data.length,r.set(t.Data,n),n=encodeVarint(r,n,t.Data.length)-1,r[n]=10),t.Links)for(let o=t.Links.length-1;o>=0;o--){const s=encodeLink(t.Links[o],r.subarray(0,n));n-=s,n=encodeVarint(r,n,s)-1,r[n]=18}return r}function sizeLink(t){let e=0;if(t.Hash){const r=t.Hash.length;e+=1+r+sov(r)}if(typeof t.Name=="string"){const r=textEncoder$3.encode(t.Name).length;e+=1+r+sov(r)}return typeof t.Tsize=="number"&&(e+=1+sov(t.Tsize)),e}function sizeNode(t){let e=0;if(t.Data){const r=t.Data.length;e+=1+r+sov(r)}if(t.Links)for(const r of t.Links){const n=sizeLink(r);e+=1+n+sov(n)}return e}function encodeVarint(t,e,r){e-=sov(r);const n=e;for(;r>=maxUInt32;)t[e++]=r&127|128,r/=128;for(;r>=128;)t[e++]=r&127|128,r>>>=7;return t[e]=r,n}function sov(t){return t%2===0&&t++,Math.floor((len64(t)+6)/7)}function len64(t){let e=0;return t>=maxInt32&&(t=Math.floor(t/maxInt32),e=32),t>=65536&&(t>>>=16,e+=16),t>=256&&(t>>>=8,e+=8),e+len8tab[t]}const len8tab=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],pbNodeProperties=["Data","Links"],pbLinkProperties=["Hash","Name","Tsize"],textEncoder$2=new TextEncoder;function linkComparator(t,e){if(t===e)return 0;const r=t.Name?textEncoder$2.encode(t.Name):[],n=e.Name?textEncoder$2.encode(e.Name):[];let o=r.length,s=n.length;for(let a=0,i=Math.min(o,s);a<i;++a)if(r[a]!==n[a]){o=r[a],s=n[a];break}return o<s?-1:s<o?1:0}function hasOnlyProperties(t,e){return!Object.keys(t).some(r=>!e.includes(r))}function asLink(t){if(typeof t.asCID=="object"){const r=CID$5.asCID(t);if(!r)throw new TypeError("Invalid DAG-PB form");return{Hash:r}}if(typeof t!="object"||Array.isArray(t))throw new TypeError("Invalid DAG-PB form");const e={};if(t.Hash){let r=CID$5.asCID(t.Hash);try{r||(typeof t.Hash=="string"?r=CID$5.parse(t.Hash):t.Hash instanceof Uint8Array&&(r=CID$5.decode(t.Hash)))}catch(n){throw new TypeError(`Invalid DAG-PB form: ${n.message}`)}r&&(e.Hash=r)}if(!e.Hash)throw new TypeError("Invalid DAG-PB form");return typeof t.Name=="string"&&(e.Name=t.Name),typeof t.Tsize=="number"&&(e.Tsize=t.Tsize),e}function prepare(t){if((t instanceof Uint8Array||typeof t=="string")&&(t={Data:t}),typeof t!="object"||Array.isArray(t))throw new TypeError("Invalid DAG-PB form");const e={};if(t.Data!==void 0)if(typeof t.Data=="string")e.Data=textEncoder$2.encode(t.Data);else if(t.Data instanceof Uint8Array)e.Data=t.Data;else throw new TypeError("Invalid DAG-PB form");if(t.Links!==void 0)if(Array.isArray(t.Links))e.Links=t.Links.map(asLink),e.Links.sort(linkComparator);else throw new TypeError("Invalid DAG-PB form");else e.Links=[];return e}function validate$2(t){if(!t||typeof t!="object"||Array.isArray(t))throw new TypeError("Invalid DAG-PB form");if(!hasOnlyProperties(t,pbNodeProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(t.Data!==void 0&&!(t.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");if(!Array.isArray(t.Links))throw new TypeError("Invalid DAG-PB form (Links must be an array)");for(let e=0;e<t.Links.length;e++){const r=t.Links[e];if(!r||typeof r!="object"||Array.isArray(r))throw new TypeError("Invalid DAG-PB form (bad link object)");if(!hasOnlyProperties(r,pbLinkProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");if(!r.Hash)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(r.Hash.asCID!==r.Hash)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(r.Name!==void 0&&typeof r.Name!="string")throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(r.Tsize!==void 0&&(typeof r.Tsize!="number"||r.Tsize%1!==0))throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(e>0&&linkComparator(r,t.Links[e-1])===-1)throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function createNode(t,e=[]){return prepare({Data:t,Links:e})}function createLink(t,e,r){return asLink({Hash:r,Name:t,Tsize:e})}const name$6="dag-pb",code$6=112;function encode$r(t){validate$2(t);const e={};return t.Links&&(e.Links=t.Links.map(r=>{const n={};return r.Hash&&(n.Hash=r.Hash.bytes),r.Name!==void 0&&(n.Name=r.Name),r.Tsize!==void 0&&(n.Tsize=r.Tsize),n})),t.Data&&(e.Data=t.Data),encodeNode(e)}function decode$B(t){const e=decodeNode(t),r={};return e.Data&&(r.Data=e.Data),e.Links&&(r.Links=e.Links.map(n=>{const o={};try{o.Hash=CID$5.decode(n.Hash)}catch{}if(!o.Hash)throw new Error("Invalid Hash field found in link, expected CID");return n.Name!==void 0&&(o.Name=n.Name),n.Tsize!==void 0&&(o.Tsize=n.Tsize),o})),r}const dagPB=Object.freeze(Object.defineProperty({__proto__:null,code:code$6,createLink,createNode,decode:decode$B,encode:encode$r,name:name$6,prepare,validate:validate$2},Symbol.toStringTag,{value:"Module"})),typeofs=["string","number","bigint","symbol"],objectTypeNames=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function is(t){if(t===null)return"null";if(t===void 0)return"undefined";if(t===!0||t===!1)return"boolean";const e=typeof t;if(typeofs.includes(e))return e;if(e==="function")return"Function";if(Array.isArray(t))return"Array";if(isBuffer$1(t))return"Buffer";const r=getObjectType(t);return r||"Object"}function isBuffer$1(t){return t&&t.constructor&&t.constructor.isBuffer&&t.constructor.isBuffer.call(null,t)}function getObjectType(t){const e=Object.prototype.toString.call(t).slice(8,-1);if(objectTypeNames.includes(e))return e}class Type{constructor(e,r,n){this.major=e,this.majorEncoded=e<<5,this.name=r,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}Type.uint=new Type(0,"uint",!0);Type.negint=new Type(1,"negint",!0);Type.bytes=new Type(2,"bytes",!0);Type.string=new Type(3,"string",!0);Type.array=new Type(4,"array",!1);Type.map=new Type(5,"map",!1);Type.tag=new Type(6,"tag",!1);Type.float=new Type(7,"float",!0);Type.false=new Type(7,"false",!0);Type.true=new Type(7,"true",!0);Type.null=new Type(7,"null",!0);Type.undefined=new Type(7,"undefined",!0);Type.break=new Type(7,"break",!0);class Token{constructor(e,r,n){this.type=e,this.value=r,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const useBuffer=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function",textDecoder$1=new TextDecoder,textEncoder$1=new TextEncoder;function isBuffer(t){return useBuffer&&globalThis.Buffer.isBuffer(t)}function asU8A(t){return t instanceof Uint8Array?isBuffer(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t:Uint8Array.from(t)}const toString$7=useBuffer?(t,e,r)=>r-e>64?globalThis.Buffer.from(t.subarray(e,r)).toString("utf8"):utf8Slice(t,e,r):(t,e,r)=>r-e>64?textDecoder$1.decode(t.subarray(e,r)):utf8Slice(t,e,r),fromString$7=useBuffer?t=>t.length>64?globalThis.Buffer.from(t):utf8ToBytes(t):t=>t.length>64?textEncoder$1.encode(t):utf8ToBytes(t),fromArray=t=>Uint8Array.from(t),slice=useBuffer?(t,e,r)=>isBuffer(t)?new Uint8Array(t.subarray(e,r)):t.slice(e,r):(t,e,r)=>t.slice(e,r),concat$2=useBuffer?(t,e)=>(t=t.map(r=>r instanceof Uint8Array?r:globalThis.Buffer.from(r)),asU8A(globalThis.Buffer.concat(t,e))):(t,e)=>{const r=new Uint8Array(e);let n=0;for(let o of t)n+o.length>r.length&&(o=o.subarray(0,r.length-n)),r.set(o,n),n+=o.length;return r},alloc=useBuffer?t=>globalThis.Buffer.allocUnsafe(t):t=>new Uint8Array(t);function compare(t,e){if(isBuffer(t)&&isBuffer(e))return t.compare(e);for(let r=0;r<t.length;r++)if(t[r]!==e[r])return t[r]<e[r]?-1:1;return 0}function utf8ToBytes(t,e=1/0){let r;const n=t.length;let o=null;const s=[];for(let a=0;a<n;++a){if(r=t.charCodeAt(a),r>55295&&r<57344){if(!o){if(r>56319){(e-=3)>-1&&s.push(239,191,189);continue}else if(a+1===n){(e-=3)>-1&&s.push(239,191,189);continue}o=r;continue}if(r<56320){(e-=3)>-1&&s.push(239,191,189),o=r;continue}r=(o-55296<<10|r-56320)+65536}else o&&(e-=3)>-1&&s.push(239,191,189);if(o=null,r<128){if((e-=1)<0)break;s.push(r)}else if(r<2048){if((e-=2)<0)break;s.push(r>>6|192,r&63|128)}else if(r<65536){if((e-=3)<0)break;s.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((e-=4)<0)break;s.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return s}function utf8Slice(t,e,r){const n=[];for(;e<r;){const o=t[e];let s=null,a=o>239?4:o>223?3:o>191?2:1;if(e+a<=r){let i,c,d,l;switch(a){case 1:o<128&&(s=o);break;case 2:i=t[e+1],(i&192)===128&&(l=(o&31)<<6|i&63,l>127&&(s=l));break;case 3:i=t[e+1],c=t[e+2],(i&192)===128&&(c&192)===128&&(l=(o&15)<<12|(i&63)<<6|c&63,l>2047&&(l<55296||l>57343)&&(s=l));break;case 4:i=t[e+1],c=t[e+2],d=t[e+3],(i&192)===128&&(c&192)===128&&(d&192)===128&&(l=(o&15)<<18|(i&63)<<12|(c&63)<<6|d&63,l>65535&&l<1114112&&(s=l))}}s===null?(s=65533,a=1):s>65535&&(s-=65536,n.push(s>>>10&1023|55296),s=56320|s&1023),n.push(s),e+=a}return decodeCodePointsArray(n)}const MAX_ARGUMENTS_LENGTH=4096;function decodeCodePointsArray(t){const e=t.length;if(e<=MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,t);let r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=MAX_ARGUMENTS_LENGTH));return r}const defaultChunkSize=256;class Bl{constructor(e=defaultChunkSize){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),this._initReuseChunk!==null&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let r=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const o=r.length-(this.maxCursor-this.cursor)-1;r.set(e,o)}else{if(r){const o=r.length-(this.maxCursor-this.cursor)-1;o<r.length&&(this.chunks[this.chunks.length-1]=r.subarray(0,o),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(r=alloc(this.chunkSize),this.chunks.push(r),this.maxCursor+=r.length,this._initReuseChunk===null&&(this._initReuseChunk=r),r.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let r;if(this.chunks.length===1){const n=this.chunks[0];e&&this.cursor>n.length/2?(r=this.cursor===n.length?n:n.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):r=slice(n,0,this.cursor)}else r=concat$2(this.chunks,this.cursor);return e&&this.reset(),r}}const decodeErrPrefix="CBOR decode error:",encodeErrPrefix="CBOR encode error:";function assertEnoughData(t,e,r){if(t.length-e<r)throw new Error(`${decodeErrPrefix} not enough data for type`)}const uintBoundaries=[24,256,65536,4294967296,BigInt("18446744073709551616")];function readUint8(t,e,r){assertEnoughData(t,e,1);const n=t[e];if(r.strict===!0&&n<uintBoundaries[0])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint16(t,e,r){assertEnoughData(t,e,2);const n=t[e]<<8|t[e+1];if(r.strict===!0&&n<uintBoundaries[1])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint32(t,e,r){assertEnoughData(t,e,4);const n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3];if(r.strict===!0&&n<uintBoundaries[2])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint64(t,e,r){assertEnoughData(t,e,8);const n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3],o=t[e+4]*16777216+(t[e+5]<<16)+(t[e+6]<<8)+t[e+7],s=(BigInt(n)<<BigInt(32))+BigInt(o);if(r.strict===!0&&s<uintBoundaries[3])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);if(s<=Number.MAX_SAFE_INTEGER)return Number(s);if(r.allowBigInt===!0)return s;throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)}function decodeUint8(t,e,r,n){return new Token(Type.uint,readUint8(t,e+1,n),2)}function decodeUint16(t,e,r,n){return new Token(Type.uint,readUint16(t,e+1,n),3)}function decodeUint32(t,e,r,n){return new Token(Type.uint,readUint32(t,e+1,n),5)}function decodeUint64(t,e,r,n){return new Token(Type.uint,readUint64(t,e+1,n),9)}function encodeUint(t,e){return encodeUintValue(t,0,e.value)}function encodeUintValue(t,e,r){if(r<uintBoundaries[0]){const n=Number(r);t.push([e|n])}else if(r<uintBoundaries[1]){const n=Number(r);t.push([e|24,n])}else if(r<uintBoundaries[2]){const n=Number(r);t.push([e|25,n>>>8,n&255])}else if(r<uintBoundaries[3]){const n=Number(r);t.push([e|26,n>>>24&255,n>>>16&255,n>>>8&255,n&255])}else{const n=BigInt(r);if(n<uintBoundaries[4]){const o=[e|27,0,0,0,0,0,0,0];let s=Number(n&BigInt(4294967295)),a=Number(n>>BigInt(32)&BigInt(4294967295));o[8]=s&255,s=s>>8,o[7]=s&255,s=s>>8,o[6]=s&255,s=s>>8,o[5]=s&255,o[4]=a&255,a=a>>8,o[3]=a&255,a=a>>8,o[2]=a&255,a=a>>8,o[1]=a&255,t.push(o)}else throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)}}encodeUint.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};encodeUintValue.encodedSize=function(e){return e<uintBoundaries[0]?1:e<uintBoundaries[1]?2:e<uintBoundaries[2]?3:e<uintBoundaries[3]?5:9};encodeUint.compareTokens=function(e,r){return e.value<r.value?-1:e.value>r.value?1:0};function decodeNegint8(t,e,r,n){return new Token(Type.negint,-1-readUint8(t,e+1,n),2)}function decodeNegint16(t,e,r,n){return new Token(Type.negint,-1-readUint16(t,e+1,n),3)}function decodeNegint32(t,e,r,n){return new Token(Type.negint,-1-readUint32(t,e+1,n),5)}const neg1b=BigInt(-1),pos1b=BigInt(1);function decodeNegint64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o!="bigint"){const s=-1-o;if(s>=Number.MIN_SAFE_INTEGER)return new Token(Type.negint,s,9)}if(n.allowBigInt!==!0)throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);return new Token(Type.negint,neg1b-BigInt(o),9)}function encodeNegint(t,e){const r=e.value,n=typeof r=="bigint"?r*neg1b-pos1b:r*-1-1;encodeUintValue(t,e.type.majorEncoded,n)}encodeNegint.encodedSize=function(e){const r=e.value,n=typeof r=="bigint"?r*neg1b-pos1b:r*-1-1;return n<uintBoundaries[0]?1:n<uintBoundaries[1]?2:n<uintBoundaries[2]?3:n<uintBoundaries[3]?5:9};encodeNegint.compareTokens=function(e,r){return e.value<r.value?1:e.value>r.value?-1:0};function toToken$3(t,e,r,n){assertEnoughData(t,e,r+n);const o=slice(t,e+r,e+r+n);return new Token(Type.bytes,o,r+n)}function decodeBytesCompact(t,e,r,n){return toToken$3(t,e,1,r)}function decodeBytes8(t,e,r,n){return toToken$3(t,e,2,readUint8(t,e+1,n))}function decodeBytes16(t,e,r,n){return toToken$3(t,e,3,readUint16(t,e+1,n))}function decodeBytes32(t,e,r,n){return toToken$3(t,e,5,readUint32(t,e+1,n))}function decodeBytes64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);return toToken$3(t,e,9,o)}function tokenBytes(t){return t.encodedBytes===void 0&&(t.encodedBytes=t.type===Type.string?fromString$7(t.value):t.value),t.encodedBytes}function encodeBytes(t,e){const r=tokenBytes(e);encodeUintValue(t,e.type.majorEncoded,r.length),t.push(r)}encodeBytes.encodedSize=function(e){const r=tokenBytes(e);return encodeUintValue.encodedSize(r.length)+r.length};encodeBytes.compareTokens=function(e,r){return compareBytes(tokenBytes(e),tokenBytes(r))};function compareBytes(t,e){return t.length<e.length?-1:t.length>e.length?1:compare(t,e)}function toToken$2(t,e,r,n,o){const s=r+n;assertEnoughData(t,e,s);const a=new Token(Type.string,toString$7(t,e+r,e+s),s);return o.retainStringBytes===!0&&(a.byteValue=slice(t,e+r,e+s)),a}function decodeStringCompact(t,e,r,n){return toToken$2(t,e,1,r,n)}function decodeString8(t,e,r,n){return toToken$2(t,e,2,readUint8(t,e+1,n),n)}function decodeString16(t,e,r,n){return toToken$2(t,e,3,readUint16(t,e+1,n),n)}function decodeString32(t,e,r,n){return toToken$2(t,e,5,readUint32(t,e+1,n),n)}function decodeString64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);return toToken$2(t,e,9,o,n)}const encodeString=encodeBytes;function toToken$1(t,e,r,n){return new Token(Type.array,n,r)}function decodeArrayCompact(t,e,r,n){return toToken$1(t,e,1,r)}function decodeArray8(t,e,r,n){return toToken$1(t,e,2,readUint8(t,e+1,n))}function decodeArray16(t,e,r,n){return toToken$1(t,e,3,readUint16(t,e+1,n))}function decodeArray32(t,e,r,n){return toToken$1(t,e,5,readUint32(t,e+1,n))}function decodeArray64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);return toToken$1(t,e,9,o)}function decodeArrayIndefinite(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken$1(t,e,1,1/0)}function encodeArray(t,e){encodeUintValue(t,Type.array.majorEncoded,e.value)}encodeArray.compareTokens=encodeUint.compareTokens;encodeArray.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};function toToken(t,e,r,n){return new Token(Type.map,n,r)}function decodeMapCompact(t,e,r,n){return toToken(t,e,1,r)}function decodeMap8(t,e,r,n){return toToken(t,e,2,readUint8(t,e+1,n))}function decodeMap16(t,e,r,n){return toToken(t,e,3,readUint16(t,e+1,n))}function decodeMap32(t,e,r,n){return toToken(t,e,5,readUint32(t,e+1,n))}function decodeMap64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);return toToken(t,e,9,o)}function decodeMapIndefinite(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken(t,e,1,1/0)}function encodeMap(t,e){encodeUintValue(t,Type.map.majorEncoded,e.value)}encodeMap.compareTokens=encodeUint.compareTokens;encodeMap.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};function decodeTagCompact(t,e,r,n){return new Token(Type.tag,r,1)}function decodeTag8(t,e,r,n){return new Token(Type.tag,readUint8(t,e+1,n),2)}function decodeTag16(t,e,r,n){return new Token(Type.tag,readUint16(t,e+1,n),3)}function decodeTag32(t,e,r,n){return new Token(Type.tag,readUint32(t,e+1,n),5)}function decodeTag64(t,e,r,n){return new Token(Type.tag,readUint64(t,e+1,n),9)}function encodeTag(t,e){encodeUintValue(t,Type.tag.majorEncoded,e.value)}encodeTag.compareTokens=encodeUint.compareTokens;encodeTag.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};const MINOR_FALSE=20,MINOR_TRUE=21,MINOR_NULL=22,MINOR_UNDEFINED=23;function decodeUndefined(t,e,r,n){if(n.allowUndefined===!1)throw new Error(`${decodeErrPrefix} undefined values are not supported`);return n.coerceUndefinedToNull===!0?new Token(Type.null,null,1):new Token(Type.undefined,void 0,1)}function decodeBreak(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return new Token(Type.break,void 0,1)}function createToken(t,e,r){if(r){if(r.allowNaN===!1&&Number.isNaN(t))throw new Error(`${decodeErrPrefix} NaN values are not supported`);if(r.allowInfinity===!1&&(t===1/0||t===-1/0))throw new Error(`${decodeErrPrefix} Infinity values are not supported`)}return new Token(Type.float,t,e)}function decodeFloat16(t,e,r,n){return createToken(readFloat16(t,e+1),3,n)}function decodeFloat32(t,e,r,n){return createToken(readFloat32(t,e+1),5,n)}function decodeFloat64(t,e,r,n){return createToken(readFloat64(t,e+1),9,n)}function encodeFloat(t,e,r){const n=e.value;if(n===!1)t.push([Type.float.majorEncoded|MINOR_FALSE]);else if(n===!0)t.push([Type.float.majorEncoded|MINOR_TRUE]);else if(n===null)t.push([Type.float.majorEncoded|MINOR_NULL]);else if(n===void 0)t.push([Type.float.majorEncoded|MINOR_UNDEFINED]);else{let o,s=!1;(!r||r.float64!==!0)&&(encodeFloat16(n),o=readFloat16(ui8a,1),n===o||Number.isNaN(n)?(ui8a[0]=249,t.push(ui8a.slice(0,3)),s=!0):(encodeFloat32(n),o=readFloat32(ui8a,1),n===o&&(ui8a[0]=250,t.push(ui8a.slice(0,5)),s=!0))),s||(encodeFloat64(n),o=readFloat64(ui8a,1),ui8a[0]=251,t.push(ui8a.slice(0,9)))}}encodeFloat.encodedSize=function(e,r){const n=e.value;if(n===!1||n===!0||n===null||n===void 0)return 1;if(!r||r.float64!==!0){encodeFloat16(n);let o=readFloat16(ui8a,1);if(n===o||Number.isNaN(n))return 3;if(encodeFloat32(n),o=readFloat32(ui8a,1),n===o)return 5}return 9};const buffer=new ArrayBuffer(9),dataView=new DataView(buffer,1),ui8a=new Uint8Array(buffer,0);function encodeFloat16(t){if(t===1/0)dataView.setUint16(0,31744,!1);else if(t===-1/0)dataView.setUint16(0,64512,!1);else if(Number.isNaN(t))dataView.setUint16(0,32256,!1);else{dataView.setFloat32(0,t);const e=dataView.getUint32(0),r=(e&2139095040)>>23,n=e&8388607;if(r===255)dataView.setUint16(0,31744,!1);else if(r===0)dataView.setUint16(0,(t&2147483648)>>16|n>>13,!1);else{const o=r-127;o<-24?dataView.setUint16(0,0):o<-14?dataView.setUint16(0,(e&2147483648)>>16|1<<24+o,!1):dataView.setUint16(0,(e&2147483648)>>16|o+15<<10|n>>13,!1)}}}function readFloat16(t,e){if(t.length-e<2)throw new Error(`${decodeErrPrefix} not enough data for float16`);const r=(t[e]<<8)+t[e+1];if(r===31744)return 1/0;if(r===64512)return-1/0;if(r===32256)return NaN;const n=r>>10&31,o=r&1023;let s;return n===0?s=o*2**-24:n!==31?s=(o+1024)*2**(n-25):s=o===0?1/0:NaN,r&32768?-s:s}function encodeFloat32(t){dataView.setFloat32(0,t,!1)}function readFloat32(t,e){if(t.length-e<4)throw new Error(`${decodeErrPrefix} not enough data for float32`);const r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,4).getFloat32(0,!1)}function encodeFloat64(t){dataView.setFloat64(0,t,!1)}function readFloat64(t,e){if(t.length-e<8)throw new Error(`${decodeErrPrefix} not enough data for float64`);const r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,8).getFloat64(0,!1)}encodeFloat.compareTokens=encodeUint.compareTokens;function invalidMinor(t,e,r){throw new Error(`${decodeErrPrefix} encountered invalid minor (${r}) for major ${t[e]>>>5}`)}function errorer(t){return()=>{throw new Error(`${decodeErrPrefix} ${t}`)}}const jump=[];for(let t=0;t<=23;t++)jump[t]=invalidMinor;jump[24]=decodeUint8;jump[25]=decodeUint16;jump[26]=decodeUint32;jump[27]=decodeUint64;jump[28]=invalidMinor;jump[29]=invalidMinor;jump[30]=invalidMinor;jump[31]=invalidMinor;for(let t=32;t<=55;t++)jump[t]=invalidMinor;jump[56]=decodeNegint8;jump[57]=decodeNegint16;jump[58]=decodeNegint32;jump[59]=decodeNegint64;jump[60]=invalidMinor;jump[61]=invalidMinor;jump[62]=invalidMinor;jump[63]=invalidMinor;for(let t=64;t<=87;t++)jump[t]=decodeBytesCompact;jump[88]=decodeBytes8;jump[89]=decodeBytes16;jump[90]=decodeBytes32;jump[91]=decodeBytes64;jump[92]=invalidMinor;jump[93]=invalidMinor;jump[94]=invalidMinor;jump[95]=errorer("indefinite length bytes/strings are not supported");for(let t=96;t<=119;t++)jump[t]=decodeStringCompact;jump[120]=decodeString8;jump[121]=decodeString16;jump[122]=decodeString32;jump[123]=decodeString64;jump[124]=invalidMinor;jump[125]=invalidMinor;jump[126]=invalidMinor;jump[127]=errorer("indefinite length bytes/strings are not supported");for(let t=128;t<=151;t++)jump[t]=decodeArrayCompact;jump[152]=decodeArray8;jump[153]=decodeArray16;jump[154]=decodeArray32;jump[155]=decodeArray64;jump[156]=invalidMinor;jump[157]=invalidMinor;jump[158]=invalidMinor;jump[159]=decodeArrayIndefinite;for(let t=160;t<=183;t++)jump[t]=decodeMapCompact;jump[184]=decodeMap8;jump[185]=decodeMap16;jump[186]=decodeMap32;jump[187]=decodeMap64;jump[188]=invalidMinor;jump[189]=invalidMinor;jump[190]=invalidMinor;jump[191]=decodeMapIndefinite;for(let t=192;t<=215;t++)jump[t]=decodeTagCompact;jump[216]=decodeTag8;jump[217]=decodeTag16;jump[218]=decodeTag32;jump[219]=decodeTag64;jump[220]=invalidMinor;jump[221]=invalidMinor;jump[222]=invalidMinor;jump[223]=invalidMinor;for(let t=224;t<=243;t++)jump[t]=errorer("simple values are not supported");jump[244]=invalidMinor;jump[245]=invalidMinor;jump[246]=invalidMinor;jump[247]=decodeUndefined;jump[248]=errorer("simple values are not supported");jump[249]=decodeFloat16;jump[250]=decodeFloat32;jump[251]=decodeFloat64;jump[252]=invalidMinor;jump[253]=invalidMinor;jump[254]=invalidMinor;jump[255]=decodeBreak;const quick=[];for(let t=0;t<24;t++)quick[t]=new Token(Type.uint,t,1);for(let t=-1;t>=-24;t--)quick[31-t]=new Token(Type.negint,t,1);quick[64]=new Token(Type.bytes,new Uint8Array(0),1);quick[96]=new Token(Type.string,"",1);quick[128]=new Token(Type.array,0,1);quick[160]=new Token(Type.map,0,1);quick[244]=new Token(Type.false,!1,1);quick[245]=new Token(Type.true,!0,1);quick[246]=new Token(Type.null,null,1);function quickEncodeToken(t){switch(t.type){case Type.false:return fromArray([244]);case Type.true:return fromArray([245]);case Type.null:return fromArray([246]);case Type.bytes:return t.value.length?void 0:fromArray([64]);case Type.string:return t.value===""?fromArray([96]):void 0;case Type.array:return t.value===0?fromArray([128]):void 0;case Type.map:return t.value===0?fromArray([160]):void 0;case Type.uint:return t.value<24?fromArray([Number(t.value)]):void 0;case Type.negint:if(t.value>=-24)return fromArray([31-Number(t.value)])}}const defaultEncodeOptions$1={float64:!1,mapSorter:mapSorter$1,quickEncodeToken};function makeCborEncoders(){const t=[];return t[Type.uint.major]=encodeUint,t[Type.negint.major]=encodeNegint,t[Type.bytes.major]=encodeBytes,t[Type.string.major]=encodeString,t[Type.array.major]=encodeArray,t[Type.map.major]=encodeMap,t[Type.tag.major]=encodeTag,t[Type.float.major]=encodeFloat,t}const cborEncoders=makeCborEncoders(),buf=new Bl;class Ref{constructor(e,r){this.obj=e,this.parent=r}includes(e){let r=this;do if(r.obj===e)return!0;while(r=r.parent);return!1}static createCheck(e,r){if(e&&e.includes(r))throw new Error(`${encodeErrPrefix} object contains circular references`);return new Ref(r,e)}}const simpleTokens={null:new Token(Type.null,null),undefined:new Token(Type.undefined,void 0),true:new Token(Type.true,!0),false:new Token(Type.false,!1),emptyArray:new Token(Type.array,0),emptyMap:new Token(Type.map,0)},typeEncoders={number(t,e,r,n){return!Number.isInteger(t)||!Number.isSafeInteger(t)?new Token(Type.float,t):t>=0?new Token(Type.uint,t):new Token(Type.negint,t)},bigint(t,e,r,n){return t>=BigInt(0)?new Token(Type.uint,t):new Token(Type.negint,t)},Uint8Array(t,e,r,n){return new Token(Type.bytes,t)},string(t,e,r,n){return new Token(Type.string,t)},boolean(t,e,r,n){return t?simpleTokens.true:simpleTokens.false},null(t,e,r,n){return simpleTokens.null},undefined(t,e,r,n){return simpleTokens.undefined},ArrayBuffer(t,e,r,n){return new Token(Type.bytes,new Uint8Array(t))},DataView(t,e,r,n){return new Token(Type.bytes,new Uint8Array(t.buffer,t.byteOffset,t.byteLength))},Array(t,e,r,n){if(!t.length)return r.addBreakTokens===!0?[simpleTokens.emptyArray,new Token(Type.break)]:simpleTokens.emptyArray;n=Ref.createCheck(n,t);const o=[];let s=0;for(const a of t)o[s++]=objectToTokens(a,r,n);return r.addBreakTokens?[new Token(Type.array,t.length),o,new Token(Type.break)]:[new Token(Type.array,t.length),o]},Object(t,e,r,n){const o=e!=="Object",s=o?t.keys():Object.keys(t),a=o?t.size:s.length;if(!a)return r.addBreakTokens===!0?[simpleTokens.emptyMap,new Token(Type.break)]:simpleTokens.emptyMap;n=Ref.createCheck(n,t);const i=[];let c=0;for(const d of s)i[c++]=[objectToTokens(d,r,n),objectToTokens(o?t.get(d):t[d],r,n)];return sortMapEntries(i,r),r.addBreakTokens?[new Token(Type.map,a),i,new Token(Type.break)]:[new Token(Type.map,a),i]}};typeEncoders.Map=typeEncoders.Object;typeEncoders.Buffer=typeEncoders.Uint8Array;for(const t of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))typeEncoders[`${t}Array`]=typeEncoders.DataView;function objectToTokens(t,e={},r){const n=is(t),o=e&&e.typeEncoders&&e.typeEncoders[n]||typeEncoders[n];if(typeof o=="function"){const a=o(t,n,e,r);if(a!=null)return a}const s=typeEncoders[n];if(!s)throw new Error(`${encodeErrPrefix} unsupported type: ${n}`);return s(t,n,e,r)}function sortMapEntries(t,e){e.mapSorter&&t.sort(e.mapSorter)}function mapSorter$1(t,e){const r=Array.isArray(t[0])?t[0][0]:t[0],n=Array.isArray(e[0])?e[0][0]:e[0];if(r.type!==n.type)return r.type.compare(n.type);const o=r.type.major,s=cborEncoders[o].compareTokens(r,n);return s===0&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),s}function tokensToEncoded(t,e,r,n){if(Array.isArray(e))for(const o of e)tokensToEncoded(t,o,r,n);else r[e.type.major](t,e,n)}function encodeCustom(t,e,r){const n=objectToTokens(t,r);if(!Array.isArray(n)&&r.quickEncodeToken){const o=r.quickEncodeToken(n);if(o)return o;const s=e[n.type.major];if(s.encodedSize){const a=s.encodedSize(n,r),i=new Bl(a);if(s(i,n,r),i.chunks.length!==1)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return asU8A(i.chunks[0])}}return buf.reset(),tokensToEncoded(buf,n,e,r),buf.toBytes(!0)}function encode$q(t,e){return e=Object.assign({},defaultEncodeOptions$1,e),encodeCustom(t,cborEncoders,e)}const defaultDecodeOptions={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Tokeniser{constructor(e,r={}){this.pos=0,this.data=e,this.options=r}done(){return this.pos>=this.data.length}next(){const e=this.data[this.pos];let r=quick[e];if(r===void 0){const n=jump[e];if(!n)throw new Error(`${decodeErrPrefix} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const o=e&31;r=n(this.data,this.pos,o,this.options)}return this.pos+=r.encodedLength,r}}const DONE=Symbol.for("DONE"),BREAK=Symbol.for("BREAK");function tokenToArray(t,e,r){const n=[];for(let o=0;o<t.value;o++){const s=tokensToObject(e,r);if(s===BREAK){if(t.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)}if(s===DONE)throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${o}, expected ${t.value})`);n[o]=s}return n}function tokenToMap(t,e,r){const n=r.useMaps===!0,o=n?void 0:{},s=n?new Map:void 0;for(let a=0;a<t.value;a++){const i=tokensToObject(e,r);if(i===BREAK){if(t.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)}if(i===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${a} [no key], expected ${t.value})`);if(n!==!0&&typeof i!="string")throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof i})`);if(r.rejectDuplicateMapKeys===!0&&(n&&s.has(i)||!n&&i in o))throw new Error(`${decodeErrPrefix} found repeat map key "${i}"`);const c=tokensToObject(e,r);if(c===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${a} [no value], expected ${t.value})`);n?s.set(i,c):o[i]=c}return n?s:o}function tokensToObject(t,e){if(t.done())return DONE;const r=t.next();if(r.type===Type.break)return BREAK;if(r.type.terminal)return r.value;if(r.type===Type.array)return tokenToArray(r,t,e);if(r.type===Type.map)return tokenToMap(r,t,e);if(r.type===Type.tag){if(e.tags&&typeof e.tags[r.value]=="function"){const n=tokensToObject(t,e);return e.tags[r.value](n)}throw new Error(`${decodeErrPrefix} tag not supported (${r.value})`)}throw new Error("unsupported")}function decode$A(t,e){if(!(t instanceof Uint8Array))throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);e=Object.assign({},defaultDecodeOptions,e);const r=e.tokenizer||new Tokeniser(t,e),n=tokensToObject(r,e);if(n===DONE)throw new Error(`${decodeErrPrefix} did not find any content to decode`);if(n===BREAK)throw new Error(`${decodeErrPrefix} got unexpected break`);if(!r.done())throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);return n}var encode_1$5=encode$p,MSB$7=128,MSBALL$5=-128,INT$5=Math.pow(2,31);function encode$p(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT$5;)e[r++]=t&255|MSB$7,t/=128;for(;t&MSBALL$5;)e[r++]=t&255|MSB$7,t>>>=7;return e[r]=t|0,encode$p.bytes=r-n+1,e}var decode$z=read$5,MSB$1$5=128,REST$1$4=127;function read$5(t,n){var r=0,n=n||0,o=0,s=n,a,i=t.length;do{if(s>=i)throw read$5.bytes=0,new RangeError("Could not decode varint");a=t[s++],r+=o<28?(a&REST$1$4)<<o:(a&REST$1$4)*Math.pow(2,o),o+=7}while(a>=MSB$1$5);return read$5.bytes=s-n,r}var N1$6=Math.pow(2,7),N2$6=Math.pow(2,14),N3$6=Math.pow(2,21),N4$6=Math.pow(2,28),N5$6=Math.pow(2,35),N6$6=Math.pow(2,42),N7$6=Math.pow(2,49),N8$5=Math.pow(2,56),N9$5=Math.pow(2,63),length$5=function(t){return t<N1$6?1:t<N2$6?2:t<N3$6?3:t<N4$6?4:t<N5$6?5:t<N6$6?6:t<N7$6?7:t<N8$5?8:t<N9$5?9:10},varint$6={encode:encode_1$5,decode:decode$z,encodingLength:length$5},_brrp_varint$4=varint$6;const decode$y=(t,e=0)=>[_brrp_varint$4.decode(t,e),_brrp_varint$4.decode.bytes],encodeTo$4=(t,e,r=0)=>(_brrp_varint$4.encode(t,e,r),e),encodingLength$5=t=>_brrp_varint$4.encodingLength(t),equals$b=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},coerce$6=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},create$7=(t,e)=>{const r=e.byteLength,n=encodingLength$5(t),o=n+encodingLength$5(r),s=new Uint8Array(o+r);return encodeTo$4(t,s,0),encodeTo$4(r,s,n),s.set(e,o),new Digest$4(t,r,e,s)},decode$x=t=>{const e=coerce$6(t),[r,n]=decode$y(e),[o,s]=decode$y(e.subarray(n)),a=e.subarray(n+s);if(a.byteLength!==o)throw new Error("Incorrect length");return new Digest$4(r,o,a,e)},equals$a=(t,e)=>{if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&equals$b(t.bytes,r.bytes)}};let Digest$4=class{constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}};function base$6(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var s=t.charAt(o),a=s.charCodeAt(0);if(r[a]!==255)throw new TypeError(s+" is ambiguous");r[a]=o}var i=t.length,c=t.charAt(0),d=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var h=0,S=0,y=0,m=u.length;y!==m&&u[y]===0;)y++,h++;for(var $=(m-y)*l+1>>>0,b=new Uint8Array($);y!==m;){for(var w=u[y],T=0,g=$-1;(w!==0||T<S)&&g!==-1;g--,T++)w+=256*b[g]>>>0,b[g]=w%i>>>0,w=w/i>>>0;if(w!==0)throw new Error("Non-zero carry");S=T,y++}for(var E=$-S;E!==$&&b[E]===0;)E++;for(var C=c.repeat(h);E<$;++E)C+=t.charAt(b[E]);return C}function p(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var h=0;if(u[h]!==" "){for(var S=0,y=0;u[h]===c;)S++,h++;for(var m=(u.length-h)*d+1>>>0,$=new Uint8Array(m);u[h];){var b=r[u.charCodeAt(h)];if(b===255)return;for(var w=0,T=m-1;(b!==0||w<y)&&T!==-1;T--,w++)b+=i*$[T]>>>0,$[T]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");y=w,h++}if(u[h]!==" "){for(var g=m-y;g!==m&&$[g]===0;)g++;for(var E=new Uint8Array(S+(m-g)),C=S;g!==m;)E[C++]=$[g++];return E}}}function v(u){var h=p(u);if(h)return h;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:p,decode:v}}var src$7=base$6,_brrp__multiformats_scope_baseX$6=src$7;let Encoder$6=class{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Decoder$6=class{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$6(this,e)}},ComposedDecoder$6=class{constructor(e){this.decoders=e}or(e){return or$6(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$6=(t,e)=>new ComposedDecoder$6({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});let Codec$6=class{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$6(e,r,n),this.decoder=new Decoder$6(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const from$7=({name:t,prefix:e,encode:r,decode:n})=>new Codec$6(t,e,r,n),baseX$6=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$6(r,e);return from$7({prefix:t,name:e,encode:n,decode:s=>coerce$6(o(s))})},decode$w=(t,e,r,n)=>{const o={};for(let l=0;l<e.length;++l)o[e[l]]=l;let s=t.length;for(;t[s-1]==="=";)--s;const a=new Uint8Array(s*r/8|0);let i=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[t[l]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<r|f,i+=r,i>=8&&(i-=8,a[d++]=255&c>>i)}if(i>=r||255&c<<8-i)throw new SyntaxError("Unexpected end of data");return a},encode$o=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let s="",a=0,i=0;for(let c=0;c<t.length;++c)for(i=i<<8|t[c],a+=8;a>r;)a-=r,s+=e[o&i>>a];if(a&&(s+=e[o&i<<r-a]),n)for(;s.length*r&7;)s+="=";return s},rfc4648$6=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$7({prefix:e,name:t,encode(o){return encode$o(o,n,r)},decode(o){return decode$w(o,n,r,t)}}),base58btc$6=baseX$6({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});baseX$6({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});const base32$a=rfc4648$6({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});rfc4648$6({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});rfc4648$6({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});rfc4648$6({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});rfc4648$6({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});rfc4648$6({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});rfc4648$6({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});rfc4648$6({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});rfc4648$6({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const format$8=(t,e)=>{const{bytes:r,version:n}=t;switch(n){case 0:return toStringV0$4(r,baseCache$4(t),e||base58btc$6.encoder);default:return toStringV1$4(r,baseCache$4(t),e||base32$a.encoder)}},cache$4=new WeakMap,baseCache$4=t=>{const e=cache$4.get(t);if(e==null){const r=new Map;return cache$4.set(t,r),r}return e};let CID$4=class D{constructor(e,r,n,o){this.code=r,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE$4)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE$4)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return D.createV0(r)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create$7(e,r);return D.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return D.equals(this,e)}static equals(e,r){const n=r;return n&&e.code===n.code&&e.version===n.version&&equals$a(e.multihash,n.multihash)}toString(e){return format$8(this,e)}toJSON(){return{"/":format$8(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const r=e;if(r instanceof D)return r;if(r["/"]!=null&&r["/"]===r.bytes||r.asCID===r){const{version:n,code:o,multihash:s,bytes:a}=r;return new D(n,o,s,a||encodeCID$5(n,o,s.bytes))}else if(r[cidSymbol$4]===!0){const{version:n,multihash:o,code:s}=r,a=decode$x(o);return D.create(n,s,a)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(r!==DAG_PB_CODE$4)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$4}) block encoding`);return new D(e,r,n,n.bytes)}case 1:{const o=encodeCID$5(e,r,n.bytes);return new D(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return D.create(0,DAG_PB_CODE$4,e)}static createV1(e,r){return D.create(1,e,r)}static decode(e){const[r,n]=D.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=D.inspectBytes(e),n=r.size-r.multihashSize,o=coerce$6(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");const s=o.subarray(r.multihashSize-r.digestSize),a=new Digest$4(r.multihashCode,r.digestSize,s,o);return[r.version===0?D.createV0(a):D.createV1(r.codec,a),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[f,p]=decode$y(e.subarray(r));return r+=p,f};let o=n(),s=DAG_PB_CODE$4;if(o===18?(o=0,r=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const a=r,i=n(),c=n(),d=r+c,l=d-a;return{version:o,codec:s,multihashCode:i,digestSize:c,multihashSize:l,size:d}}static parse(e,r){const[n,o]=parseCIDtoBytes$4(e,r),s=D.decode(o);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return baseCache$4(s).set(n,e),s}};const parseCIDtoBytes$4=(t,e)=>{switch(t[0]){case"Q":{const r=e||base58btc$6;return[base58btc$6.prefix,r.decode(`${base58btc$6.prefix}${t}`)]}case base58btc$6.prefix:{const r=e||base58btc$6;return[base58btc$6.prefix,r.decode(t)]}case base32$a.prefix:{const r=e||base32$a;return[base32$a.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},toStringV0$4=(t,e,r)=>{const{prefix:n}=r;if(n!==base58btc$6.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=e.get(n);if(o==null){const s=r.encode(t).slice(1);return e.set(n,s),s}else return o},toStringV1$4=(t,e,r)=>{const{prefix:n}=r,o=e.get(n);if(o==null){const s=r.encode(t);return e.set(n,s),s}else return o},DAG_PB_CODE$4=112,SHA_256_CODE$4=18,encodeCID$5=(t,e,r)=>{const n=encodingLength$5(t),o=n+encodingLength$5(e),s=new Uint8Array(o+r.byteLength);return encodeTo$4(t,s,0),encodeTo$4(e,s,n),s.set(r,o),s},cidSymbol$4=Symbol.for("@ipld/js-cid/CID"),CID_CBOR_TAG=42;function cidEncoder$1(t){if(t.asCID!==t&&t["/"]!==t.bytes)return null;const e=CID$4.asCID(t);if(!e)return null;const r=new Uint8Array(e.bytes.byteLength+1);return r.set(e.bytes,1),[new Token(Type.tag,CID_CBOR_TAG),new Token(Type.bytes,r)]}function undefinedEncoder$1(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder$1(t){if(Number.isNaN(t))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(t===1/0||t===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const encodeOptions$1={float64:!0,typeEncoders:{Object:cidEncoder$1,undefined:undefinedEncoder$1,number:numberEncoder$1}};function cidDecoder(t){if(t[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID$4.decode(t.subarray(1))}const decodeOptions$1={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions$1.tags[CID_CBOR_TAG]=cidDecoder;const name$5="dag-cbor",code$5=113,encode$n=t=>encode$q(t,encodeOptions$1),decode$v=t=>decode$A(t,decodeOptions$1),dagCBOR=Object.freeze(Object.defineProperty({__proto__:null,code:code$5,decode:decode$v,encode:encode$n,name:name$5},Symbol.toStringTag,{value:"Module"}));var encode_1$4=encode$m,MSB$6=128,MSBALL$4=-128,INT$4=Math.pow(2,31);function encode$m(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT$4;)e[r++]=t&255|MSB$6,t/=128;for(;t&MSBALL$4;)e[r++]=t&255|MSB$6,t>>>=7;return e[r]=t|0,encode$m.bytes=r-n+1,e}var decode$u=read$4,MSB$1$4=128,REST$1$3=127;function read$4(t,n){var r=0,n=n||0,o=0,s=n,a,i=t.length;do{if(s>=i)throw read$4.bytes=0,new RangeError("Could not decode varint");a=t[s++],r+=o<28?(a&REST$1$3)<<o:(a&REST$1$3)*Math.pow(2,o),o+=7}while(a>=MSB$1$4);return read$4.bytes=s-n,r}var N1$5=Math.pow(2,7),N2$5=Math.pow(2,14),N3$5=Math.pow(2,21),N4$5=Math.pow(2,28),N5$5=Math.pow(2,35),N6$5=Math.pow(2,42),N7$5=Math.pow(2,49),N8$4=Math.pow(2,56),N9$4=Math.pow(2,63),length$4=function(t){return t<N1$5?1:t<N2$5?2:t<N3$5?3:t<N4$5?4:t<N5$5?5:t<N6$5?6:t<N7$5?7:t<N8$4?8:t<N9$4?9:10},varint$5={encode:encode_1$4,decode:decode$u,encodingLength:length$4},_brrp_varint$3=varint$5;const decode$t=(t,e=0)=>[_brrp_varint$3.decode(t,e),_brrp_varint$3.decode.bytes],encodeTo$3=(t,e,r=0)=>(_brrp_varint$3.encode(t,e,r),e),encodingLength$4=t=>_brrp_varint$3.encodingLength(t),equals$9=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},coerce$5=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},create$6=(t,e)=>{const r=e.byteLength,n=encodingLength$4(t),o=n+encodingLength$4(r),s=new Uint8Array(o+r);return encodeTo$3(t,s,0),encodeTo$3(r,s,n),s.set(e,o),new Digest$3(t,r,e,s)},decode$s=t=>{const e=coerce$5(t),[r,n]=decode$t(e),[o,s]=decode$t(e.subarray(n)),a=e.subarray(n+s);if(a.byteLength!==o)throw new Error("Incorrect length");return new Digest$3(r,o,a,e)},equals$8=(t,e)=>{if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&equals$9(t.bytes,r.bytes)}};let Digest$3=class{constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}};function base$5(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var s=t.charAt(o),a=s.charCodeAt(0);if(r[a]!==255)throw new TypeError(s+" is ambiguous");r[a]=o}var i=t.length,c=t.charAt(0),d=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var h=0,S=0,y=0,m=u.length;y!==m&&u[y]===0;)y++,h++;for(var $=(m-y)*l+1>>>0,b=new Uint8Array($);y!==m;){for(var w=u[y],T=0,g=$-1;(w!==0||T<S)&&g!==-1;g--,T++)w+=256*b[g]>>>0,b[g]=w%i>>>0,w=w/i>>>0;if(w!==0)throw new Error("Non-zero carry");S=T,y++}for(var E=$-S;E!==$&&b[E]===0;)E++;for(var C=c.repeat(h);E<$;++E)C+=t.charAt(b[E]);return C}function p(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var h=0;if(u[h]!==" "){for(var S=0,y=0;u[h]===c;)S++,h++;for(var m=(u.length-h)*d+1>>>0,$=new Uint8Array(m);u[h];){var b=r[u.charCodeAt(h)];if(b===255)return;for(var w=0,T=m-1;(b!==0||w<y)&&T!==-1;T--,w++)b+=i*$[T]>>>0,$[T]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");y=w,h++}if(u[h]!==" "){for(var g=m-y;g!==m&&$[g]===0;)g++;for(var E=new Uint8Array(S+(m-g)),C=S;g!==m;)E[C++]=$[g++];return E}}}function v(u){var h=p(u);if(h)return h;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:p,decode:v}}var src$6=base$5,_brrp__multiformats_scope_baseX$5=src$6;let Encoder$5=class{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Decoder$5=class{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$5(this,e)}},ComposedDecoder$5=class{constructor(e){this.decoders=e}or(e){return or$5(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$5=(t,e)=>new ComposedDecoder$5({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});let Codec$5=class{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$5(e,r,n),this.decoder=new Decoder$5(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const from$6=({name:t,prefix:e,encode:r,decode:n})=>new Codec$5(t,e,r,n),baseX$5=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$5(r,e);return from$6({prefix:t,name:e,encode:n,decode:s=>coerce$5(o(s))})},decode$r=(t,e,r,n)=>{const o={};for(let l=0;l<e.length;++l)o[e[l]]=l;let s=t.length;for(;t[s-1]==="=";)--s;const a=new Uint8Array(s*r/8|0);let i=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[t[l]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<r|f,i+=r,i>=8&&(i-=8,a[d++]=255&c>>i)}if(i>=r||255&c<<8-i)throw new SyntaxError("Unexpected end of data");return a},encode$l=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let s="",a=0,i=0;for(let c=0;c<t.length;++c)for(i=i<<8|t[c],a+=8;a>r;)a-=r,s+=e[o&i>>a];if(a&&(s+=e[o&i<<r-a]),n)for(;s.length*r&7;)s+="=";return s},rfc4648$5=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$6({prefix:e,name:t,encode(o){return encode$l(o,n,r)},decode(o){return decode$r(o,n,r,t)}}),base58btc$5=baseX$5({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});baseX$5({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});const base32$9=rfc4648$5({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});rfc4648$5({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});rfc4648$5({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});rfc4648$5({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});rfc4648$5({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});rfc4648$5({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});rfc4648$5({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});rfc4648$5({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});rfc4648$5({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const format$7=(t,e)=>{const{bytes:r,version:n}=t;switch(n){case 0:return toStringV0$3(r,baseCache$3(t),e||base58btc$5.encoder);default:return toStringV1$3(r,baseCache$3(t),e||base32$9.encoder)}},cache$3=new WeakMap,baseCache$3=t=>{const e=cache$3.get(t);if(e==null){const r=new Map;return cache$3.set(t,r),r}return e};let CID$3=class B{constructor(e,r,n,o){this.code=r,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE$3)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE$3)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return B.createV0(r)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create$6(e,r);return B.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return B.equals(this,e)}static equals(e,r){const n=r;return n&&e.code===n.code&&e.version===n.version&&equals$8(e.multihash,n.multihash)}toString(e){return format$7(this,e)}toJSON(){return{"/":format$7(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const r=e;if(r instanceof B)return r;if(r["/"]!=null&&r["/"]===r.bytes||r.asCID===r){const{version:n,code:o,multihash:s,bytes:a}=r;return new B(n,o,s,a||encodeCID$4(n,o,s.bytes))}else if(r[cidSymbol$3]===!0){const{version:n,multihash:o,code:s}=r,a=decode$s(o);return B.create(n,s,a)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(r!==DAG_PB_CODE$3)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$3}) block encoding`);return new B(e,r,n,n.bytes)}case 1:{const o=encodeCID$4(e,r,n.bytes);return new B(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return B.create(0,DAG_PB_CODE$3,e)}static createV1(e,r){return B.create(1,e,r)}static decode(e){const[r,n]=B.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=B.inspectBytes(e),n=r.size-r.multihashSize,o=coerce$5(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");const s=o.subarray(r.multihashSize-r.digestSize),a=new Digest$3(r.multihashCode,r.digestSize,s,o);return[r.version===0?B.createV0(a):B.createV1(r.codec,a),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[f,p]=decode$t(e.subarray(r));return r+=p,f};let o=n(),s=DAG_PB_CODE$3;if(o===18?(o=0,r=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const a=r,i=n(),c=n(),d=r+c,l=d-a;return{version:o,codec:s,multihashCode:i,digestSize:c,multihashSize:l,size:d}}static parse(e,r){const[n,o]=parseCIDtoBytes$3(e,r),s=B.decode(o);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return baseCache$3(s).set(n,e),s}};const parseCIDtoBytes$3=(t,e)=>{switch(t[0]){case"Q":{const r=e||base58btc$5;return[base58btc$5.prefix,r.decode(`${base58btc$5.prefix}${t}`)]}case base58btc$5.prefix:{const r=e||base58btc$5;return[base58btc$5.prefix,r.decode(t)]}case base32$9.prefix:{const r=e||base32$9;return[base32$9.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},toStringV0$3=(t,e,r)=>{const{prefix:n}=r;if(n!==base58btc$5.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=e.get(n);if(o==null){const s=r.encode(t).slice(1);return e.set(n,s),s}else return o},toStringV1$3=(t,e,r)=>{const{prefix:n}=r,o=e.get(n);if(o==null){const s=r.encode(t);return e.set(n,s),s}else return o},DAG_PB_CODE$3=112,SHA_256_CODE$3=18,encodeCID$4=(t,e,r)=>{const n=encodingLength$4(t),o=n+encodingLength$4(e),s=new Uint8Array(o+r.byteLength);return encodeTo$3(t,s,0),encodeTo$3(e,s,n),s.set(r,o),s},cidSymbol$3=Symbol.for("@ipld/js-cid/CID"),base64$b=rfc4648$5({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6});rfc4648$5({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6});rfc4648$5({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6});rfc4648$5({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});class JSONEncoder extends Array{constructor(){super(),this.inRecursive=[]}prefix(e){const r=this.inRecursive[this.inRecursive.length-1];r&&(r.type===Type.array&&(r.elements++,r.elements!==1&&e.push([44])),r.type===Type.map&&(r.elements++,r.elements!==1&&(r.elements%2===1?e.push([44]):e.push([58]))))}[Type.uint.major](e,r){this.prefix(e);const n=String(r.value),o=[];for(let s=0;s<n.length;s++)o[s]=n.charCodeAt(s);e.push(o)}[Type.negint.major](e,r){this[Type.uint.major](e,r)}[Type.bytes.major](e,r){throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)}[Type.string.major](e,r){this.prefix(e);const n=fromString$7(JSON.stringify(r.value));e.push(n.length>32?asU8A(n):n)}[Type.array.major](e,r){this.prefix(e),this.inRecursive.push({type:Type.array,elements:0}),e.push([91])}[Type.map.major](e,r){this.prefix(e),this.inRecursive.push({type:Type.map,elements:0}),e.push([123])}[Type.tag.major](e,r){}[Type.float.major](e,r){if(r.type.name==="break"){const a=this.inRecursive.pop();if(a){if(a.type===Type.array)e.push([93]);else if(a.type===Type.map)e.push([125]);else throw new Error("Unexpected recursive type; this should not happen!");return}throw new Error("Unexpected break; this should not happen!")}if(r.value===void 0)throw new Error(`${encodeErrPrefix} unsupported type: undefined`);if(this.prefix(e),r.type.name==="true"){e.push([116,114,117,101]);return}else if(r.type.name==="false"){e.push([102,97,108,115,101]);return}else if(r.type.name==="null"){e.push([110,117,108,108]);return}const n=String(r.value),o=[];let s=!1;for(let a=0;a<n.length;a++)o[a]=n.charCodeAt(a),!s&&(o[a]===46||o[a]===101||o[a]===69)&&(s=!0);s||(o.push(46),o.push(48)),e.push(o)}}function mapSorter(t,e){if(Array.isArray(t[0])||Array.isArray(e[0]))throw new Error(`${encodeErrPrefix} complex map keys are not supported`);const r=t[0],n=e[0];if(r.type!==Type.string||n.type!==Type.string)throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);if(r<n)return-1;if(r>n)return 1;throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)}const defaultEncodeOptions={addBreakTokens:!0,mapSorter};function encode$k(t,e){return e=Object.assign({},defaultEncodeOptions,e),encodeCustom(t,new JSONEncoder,e)}class Tokenizer{constructor(e,r={}){this.pos=0,this.data=e,this.options=r,this.modeStack=["value"],this.lastToken=""}done(){return this.pos>=this.data.length}ch(){return this.data[this.pos]}currentMode(){return this.modeStack[this.modeStack.length-1]}skipWhitespace(){let e=this.ch();for(;e===32||e===9||e===13||e===10;)e=this.data[++this.pos]}expect(e){if(this.data.length-this.pos<e.length)throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);for(let r=0;r<e.length;r++)if(this.data[this.pos++]!==e[r])throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...e)}'`)}parseNumber(){const e=this.pos;let r=!1,n=!1;const o=i=>{for(;!this.done();){const c=this.ch();if(i.includes(c))this.pos++;else break}};if(this.ch()===45&&(r=!0,this.pos++),this.ch()===48)if(this.pos++,this.ch()===46)this.pos++,n=!0;else return new Token(Type.uint,0,this.pos-e);if(o([48,49,50,51,52,53,54,55,56,57]),r&&this.pos===e+1)throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);if(!this.done()&&this.ch()===46){if(n)throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);n=!0,this.pos++,o([48,49,50,51,52,53,54,55,56,57])}!this.done()&&(this.ch()===101||this.ch()===69)&&(n=!0,this.pos++,!this.done()&&(this.ch()===43||this.ch()===45)&&this.pos++,o([48,49,50,51,52,53,54,55,56,57]));const s=String.fromCharCode.apply(null,this.data.subarray(e,this.pos)),a=parseFloat(s);return n?new Token(Type.float,a,this.pos-e):this.options.allowBigInt!==!0||Number.isSafeInteger(a)?new Token(a>=0?Type.uint:Type.negint,a,this.pos-e):new Token(a>=0?Type.uint:Type.negint,BigInt(s),this.pos-e)}parseString(){if(this.ch()!==34)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);this.pos++;for(let s=this.pos,a=0;s<this.data.length&&a<65536;s++,a++){const i=this.data[s];if(i===92||i<32||i>=128)break;if(i===34){const c=String.fromCharCode.apply(null,this.data.subarray(this.pos,s));return this.pos=s+1,new Token(Type.string,c,a)}}const e=this.pos,r=[],n=()=>{if(this.pos+4>=this.data.length)throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);let s=0;for(let a=0;a<4;a++){let i=this.ch();if(i>=48&&i<=57)i-=48;else if(i>=97&&i<=102)i=i-97+10;else if(i>=65&&i<=70)i=i-65+10;else throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);s=s*16+i,this.pos++}return s},o=()=>{const s=this.ch();let a=null,i=s>239?4:s>223?3:s>191?2:1;if(this.pos+i>this.data.length)throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);let c,d,l,f;switch(i){case 1:s<128&&(a=s);break;case 2:c=this.data[this.pos+1],(c&192)===128&&(f=(s&31)<<6|c&63,f>127&&(a=f));break;case 3:c=this.data[this.pos+1],d=this.data[this.pos+2],(c&192)===128&&(d&192)===128&&(f=(s&15)<<12|(c&63)<<6|d&63,f>2047&&(f<55296||f>57343)&&(a=f));break;case 4:c=this.data[this.pos+1],d=this.data[this.pos+2],l=this.data[this.pos+3],(c&192)===128&&(d&192)===128&&(l&192)===128&&(f=(s&15)<<18|(c&63)<<12|(d&63)<<6|l&63,f>65535&&f<1114112&&(a=f))}a===null?(a=65533,i=1):a>65535&&(a-=65536,r.push(a>>>10&1023|55296),a=56320|a&1023),r.push(a),this.pos+=i};for(;!this.done();){const s=this.ch();let a;switch(s){case 92:if(this.pos++,this.done())throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);switch(a=this.ch(),this.pos++,a){case 34:case 39:case 92:case 47:r.push(a);break;case 98:r.push(8);break;case 116:r.push(9);break;case 110:r.push(10);break;case 102:r.push(12);break;case 114:r.push(13);break;case 117:r.push(n());break;default:throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`)}break;case 34:return this.pos++,new Token(Type.string,decodeCodePointsArray(r),this.pos-e);default:if(s<32)throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);s<128?(r.push(s),this.pos++):o()}}throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`)}parseValue(){switch(this.ch()){case 123:return this.modeStack.push("obj-start"),this.pos++,new Token(Type.map,1/0,1);case 91:return this.modeStack.push("array-start"),this.pos++,new Token(Type.array,1/0,1);case 34:return this.parseString();case 110:return this.expect([110,117,108,108]),new Token(Type.null,null,4);case 102:return this.expect([102,97,108,115,101]),new Token(Type.false,!1,5);case 116:return this.expect([116,114,117,101]),new Token(Type.true,!0,4);case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.parseNumber();default:throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`)}}next(){switch(this.skipWhitespace(),this.currentMode()){case"value":return this.modeStack.pop(),this.parseValue();case"array-value":{if(this.modeStack.pop(),this.ch()===93)return this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);if(this.ch()!==44)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);return this.pos++,this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue()}case"array-start":return this.modeStack.pop(),this.ch()===93?(this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1)):(this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue());case"obj-key":if(this.ch()===125)return this.modeStack.pop(),this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);if(this.ch()!==44)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);this.pos++,this.skipWhitespace();case"obj-start":{if(this.modeStack.pop(),this.ch()===125)return this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);const e=this.parseString();if(this.skipWhitespace(),this.ch()!==58)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);return this.pos++,this.modeStack.push("obj-value"),e}case"obj-value":return this.modeStack.pop(),this.modeStack.push("obj-key"),this.skipWhitespace(),this.parseValue();default:throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`)}}}function decode$q(t,e){return e=Object.assign({tokenizer:new Tokenizer(t,e)},e),decode$A(t,e)}function cidEncoder(t){if(t.asCID!==t&&t["/"]!==t.bytes)return null;const e=CID$3.asCID(t);if(!e)return null;const r=e.toString();return[new Token(Type.map,1/0,1),new Token(Type.string,"/",1),new Token(Type.string,r,r.length),new Token(Type.break,void 0,1)]}function bytesEncoder(t){const e=base64$b.encode(t).slice(1);return[new Token(Type.map,1/0,1),new Token(Type.string,"/",1),new Token(Type.map,1/0,1),new Token(Type.string,"bytes",5),new Token(Type.string,e,e.length),new Token(Type.break,void 0,1),new Token(Type.break,void 0,1)]}function undefinedEncoder(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder(t){if(Number.isNaN(t))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(t===1/0||t===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const encodeOptions={typeEncoders:{Object:cidEncoder,Uint8Array:bytesEncoder,Buffer:bytesEncoder,undefined:undefinedEncoder,number:numberEncoder}};class DagJsonTokenizer extends Tokenizer{constructor(e,r){super(e,r),this.tokenBuffer=[]}done(){return this.tokenBuffer.length===0&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const e=this._next();if(e.type===Type.map){const r=this._next();if(r.type===Type.string&&r.value==="/"){const n=this._next();if(n.type===Type.string){if(this._next().type!==Type.break)throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(n),new Token(Type.tag,42,0)}if(n.type===Type.map){const o=this._next();if(o.type===Type.string&&o.value==="bytes"){const s=this._next();if(s.type===Type.string){for(let i=0;i<2;i++)if(this._next().type!==Type.break)throw new Error("Invalid encoded Bytes form");const a=base64$b.decode(`m${s.value}`);return new Token(Type.bytes,a,s.value.length)}this.tokenBuffer.push(s)}this.tokenBuffer.push(o)}this.tokenBuffer.push(n)}this.tokenBuffer.push(r)}return e}}const decodeOptions={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions.tags[42]=CID$3.parse;const name$4="dag-json",code$4=297,encode$j=t=>encode$k(t,encodeOptions),decode$p=t=>{const e=Object.assign(decodeOptions,{tokenizer:new DagJsonTokenizer(t,decodeOptions)});return decode$q(t,e)},format$6=t=>utf8Decoder.decode(encode$j(t)),utf8Decoder=new TextDecoder,parse$1=t=>decode$p(utf8Encoder.encode(t)),utf8Encoder=new TextEncoder,dagJSON=Object.freeze(Object.defineProperty({__proto__:null,code:code$4,decode:decode$p,encode:encode$j,format:format$6,name:name$4,parse:parse$1,stringify:format$6},Symbol.toStringTag,{value:"Module"}));function base$4(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var s=t.charAt(o),a=s.charCodeAt(0);if(r[a]!==255)throw new TypeError(s+" is ambiguous");r[a]=o}var i=t.length,c=t.charAt(0),d=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var h=0,S=0,y=0,m=u.length;y!==m&&u[y]===0;)y++,h++;for(var $=(m-y)*l+1>>>0,b=new Uint8Array($);y!==m;){for(var w=u[y],T=0,g=$-1;(w!==0||T<S)&&g!==-1;g--,T++)w+=256*b[g]>>>0,b[g]=w%i>>>0,w=w/i>>>0;if(w!==0)throw new Error("Non-zero carry");S=T,y++}for(var E=$-S;E!==$&&b[E]===0;)E++;for(var C=c.repeat(h);E<$;++E)C+=t.charAt(b[E]);return C}function p(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var h=0;if(u[h]!==" "){for(var S=0,y=0;u[h]===c;)S++,h++;for(var m=(u.length-h)*d+1>>>0,$=new Uint8Array(m);u[h];){var b=r[u.charCodeAt(h)];if(b===255)return;for(var w=0,T=m-1;(b!==0||w<y)&&T!==-1;T--,w++)b+=i*$[T]>>>0,$[T]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");y=w,h++}if(u[h]!==" "){for(var g=m-y;g!==m&&$[g]===0;)g++;for(var E=new Uint8Array(S+(m-g)),C=S;g!==m;)E[C++]=$[g++];return E}}}function v(u){var h=p(u);if(h)return h;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:p,decode:v}}var src$5=base$4,_brrp__multiformats_scope_baseX$4=src$5;const equals$7=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},coerce$4=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},fromString$6=t=>new TextEncoder().encode(t),toString$6=t=>new TextDecoder().decode(t);let Encoder$4=class{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Decoder$4=class{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$4(this,e)}},ComposedDecoder$4=class{constructor(e){this.decoders=e}or(e){return or$4(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$4=(t,e)=>new ComposedDecoder$4({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});let Codec$4=class{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$4(e,r,n),this.decoder=new Decoder$4(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const from$5=({name:t,prefix:e,encode:r,decode:n})=>new Codec$4(t,e,r,n),baseX$4=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$4(r,e);return from$5({prefix:t,name:e,encode:n,decode:s=>coerce$4(o(s))})},decode$o=(t,e,r,n)=>{const o={};for(let l=0;l<e.length;++l)o[e[l]]=l;let s=t.length;for(;t[s-1]==="=";)--s;const a=new Uint8Array(s*r/8|0);let i=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[t[l]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<r|f,i+=r,i>=8&&(i-=8,a[d++]=255&c>>i)}if(i>=r||255&c<<8-i)throw new SyntaxError("Unexpected end of data");return a},encode$i=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let s="",a=0,i=0;for(let c=0;c<t.length;++c)for(i=i<<8|t[c],a+=8;a>r;)a-=r,s+=e[o&i>>a];if(a&&(s+=e[o&i<<r-a]),n)for(;s.length*r&7;)s+="=";return s},rfc4648$4=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$5({prefix:e,name:t,encode(o){return encode$i(o,n,r)},decode(o){return decode$o(o,n,r,t)}}),base64$9=rfc4648$4({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad$3=rfc4648$4({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url$3=rfc4648$4({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad$3=rfc4648$4({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$a=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$9,base64pad:base64pad$3,base64url:base64url$3,base64urlpad:base64urlpad$3},Symbol.toStringTag,{value:"Module"}));function toBase64url(t){return base64url$3.encode(t).slice(1)}function fromBase64url(t){return base64url$3.decode(`u${t}`)}var encode_1$3=encode$h,MSB$5=128,MSBALL$3=-128,INT$3=Math.pow(2,31);function encode$h(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT$3;)e[r++]=t&255|MSB$5,t/=128;for(;t&MSBALL$3;)e[r++]=t&255|MSB$5,t>>>=7;return e[r]=t|0,encode$h.bytes=r-n+1,e}var decode$n=read$3,MSB$1$3=128,REST$1$2=127;function read$3(t,n){var r=0,n=n||0,o=0,s=n,a,i=t.length;do{if(s>=i)throw read$3.bytes=0,new RangeError("Could not decode varint");a=t[s++],r+=o<28?(a&REST$1$2)<<o:(a&REST$1$2)*Math.pow(2,o),o+=7}while(a>=MSB$1$3);return read$3.bytes=s-n,r}var N1$4=Math.pow(2,7),N2$4=Math.pow(2,14),N3$4=Math.pow(2,21),N4$4=Math.pow(2,28),N5$4=Math.pow(2,35),N6$4=Math.pow(2,42),N7$4=Math.pow(2,49),N8$3=Math.pow(2,56),N9$3=Math.pow(2,63),length$3=function(t){return t<N1$4?1:t<N2$4?2:t<N3$4?3:t<N4$4?4:t<N5$4?5:t<N6$4?6:t<N7$4?7:t<N8$3?8:t<N9$3?9:10},varint$4={encode:encode_1$3,decode:decode$n,encodingLength:length$3},_brrp_varint$2=varint$4;const decode$m=(t,e=0)=>[_brrp_varint$2.decode(t,e),_brrp_varint$2.decode.bytes],encodeTo$2=(t,e,r=0)=>(_brrp_varint$2.encode(t,e,r),e),encodingLength$3=t=>_brrp_varint$2.encodingLength(t),create$5=(t,e)=>{const r=e.byteLength,n=encodingLength$3(t),o=n+encodingLength$3(r),s=new Uint8Array(o+r);return encodeTo$2(t,s,0),encodeTo$2(r,s,n),s.set(e,o),new Digest$2(t,r,e,s)},decode$l=t=>{const e=coerce$4(t),[r,n]=decode$m(e),[o,s]=decode$m(e.subarray(n)),a=e.subarray(n+s);if(a.byteLength!==o)throw new Error("Incorrect length");return new Digest$2(r,o,a,e)},equals$6=(t,e)=>{if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&equals$7(t.bytes,r.bytes)}};let Digest$2=class{constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}};const base58btc$4=baseX$4({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr$3=baseX$4({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58$3=Object.freeze(Object.defineProperty({__proto__:null,base58btc:base58btc$4,base58flickr:base58flickr$3},Symbol.toStringTag,{value:"Module"})),base32$7=rfc4648$4({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper$3=rfc4648$4({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad$3=rfc4648$4({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper$3=rfc4648$4({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex$3=rfc4648$4({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper$3=rfc4648$4({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad$3=rfc4648$4({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper$3=rfc4648$4({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z$3=rfc4648$4({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$8=Object.freeze(Object.defineProperty({__proto__:null,base32:base32$7,base32hex:base32hex$3,base32hexpad:base32hexpad$3,base32hexpadupper:base32hexpadupper$3,base32hexupper:base32hexupper$3,base32pad:base32pad$3,base32padupper:base32padupper$3,base32upper:base32upper$3,base32z:base32z$3},Symbol.toStringTag,{value:"Module"})),format$5=(t,e)=>{const{bytes:r,version:n}=t;switch(n){case 0:return toStringV0$2(r,baseCache$2(t),e||base58btc$4.encoder);default:return toStringV1$2(r,baseCache$2(t),e||base32$7.encoder)}},cache$2=new WeakMap,baseCache$2=t=>{const e=cache$2.get(t);if(e==null){const r=new Map;return cache$2.set(t,r),r}return e};let CID$2=class I{constructor(e,r,n,o){this.code=r,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE$2)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE$2)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return I.createV0(r)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create$5(e,r);return I.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return I.equals(this,e)}static equals(e,r){const n=r;return n&&e.code===n.code&&e.version===n.version&&equals$6(e.multihash,n.multihash)}toString(e){return format$5(this,e)}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const r=e;if(r instanceof I)return r;if(r["/"]!=null&&r["/"]===r.bytes||r.asCID===r){const{version:n,code:o,multihash:s,bytes:a}=r;return new I(n,o,s,a||encodeCID$3(n,o,s.bytes))}else if(r[cidSymbol$2]===!0){const{version:n,multihash:o,code:s}=r,a=decode$l(o);return I.create(n,s,a)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(r!==DAG_PB_CODE$2)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$2}) block encoding`);return new I(e,r,n,n.bytes)}case 1:{const o=encodeCID$3(e,r,n.bytes);return new I(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return I.create(0,DAG_PB_CODE$2,e)}static createV1(e,r){return I.create(1,e,r)}static decode(e){const[r,n]=I.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=I.inspectBytes(e),n=r.size-r.multihashSize,o=coerce$4(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");const s=o.subarray(r.multihashSize-r.digestSize),a=new Digest$2(r.multihashCode,r.digestSize,s,o);return[r.version===0?I.createV0(a):I.createV1(r.codec,a),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[f,p]=decode$m(e.subarray(r));return r+=p,f};let o=n(),s=DAG_PB_CODE$2;if(o===18?(o=0,r=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const a=r,i=n(),c=n(),d=r+c,l=d-a;return{version:o,codec:s,multihashCode:i,digestSize:c,multihashSize:l,size:d}}static parse(e,r){const[n,o]=parseCIDtoBytes$2(e,r),s=I.decode(o);return baseCache$2(s).set(n,e),s}};const parseCIDtoBytes$2=(t,e)=>{switch(t[0]){case"Q":{const r=e||base58btc$4;return[base58btc$4.prefix,r.decode(`${base58btc$4.prefix}${t}`)]}case base58btc$4.prefix:{const r=e||base58btc$4;return[base58btc$4.prefix,r.decode(t)]}case base32$7.prefix:{const r=e||base32$7;return[base32$7.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},toStringV0$2=(t,e,r)=>{const{prefix:n}=r;if(n!==base58btc$4.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=e.get(n);if(o==null){const s=r.encode(t).slice(1);return e.set(n,s),s}else return o},toStringV1$2=(t,e,r)=>{const{prefix:n}=r,o=e.get(n);if(o==null){const s=r.encode(t);return e.set(n,s),s}else return o},DAG_PB_CODE$2=112,SHA_256_CODE$2=18,encodeCID$3=(t,e,r)=>{const n=encodingLength$3(t),o=n+encodingLength$3(e),s=new Uint8Array(o+r.byteLength);return encodeTo$2(t,s,0),encodeTo$2(e,s,n),s.set(r,o),s},cidSymbol$2=Symbol.for("@ipld/js-cid/CID");function fromSplit$1(t){const[e,r,n]=t;return{payload:r,signatures:[{protected:e,signature:n}],link:CID$2.decode(fromBase64url(r))}}function encodeSignature(t){const e={signature:fromBase64url(t.signature)};return t.header&&(e.header=t.header),t.protected&&(e.protected=fromBase64url(t.protected)),e}function encode$g(t){const e=fromBase64url(t.payload);try{CID$2.decode(e)}catch{throw new Error("Not a valid DagJWS")}return{payload:e,signatures:t.signatures.map(encodeSignature)}}function decodeSignature(t){const e={signature:toBase64url(t.signature)};return t.header&&(e.header=t.header),t.protected&&(e.protected=toBase64url(t.protected)),e}function decode$k(t){const e={payload:toBase64url(t.payload),signatures:t.signatures.map(decodeSignature)};return e.link=CID$2.decode(new Uint8Array(t.payload)),e}function fromSplit(t){const[e,r,n,o,s]=t,a={ciphertext:o,iv:n,protected:e,tag:s};return r&&(a.recipients=[{encrypted_key:r}]),a}function encodeRecipient(t){const e={};return t.encrypted_key&&(e.encrypted_key=fromBase64url(t.encrypted_key)),t.header&&(e.header=t.header),e}function encode$f(t){const e={ciphertext:fromBase64url(t.ciphertext),protected:fromBase64url(t.protected),iv:fromBase64url(t.iv),tag:fromBase64url(t.tag)};return t.aad&&(e.aad=fromBase64url(t.aad)),t.recipients&&(e.recipients=t.recipients.map(encodeRecipient)),t.unprotected&&(e.unprotected=t.unprotected),e}function decodeRecipient(t){const e={};return t.encrypted_key&&(e.encrypted_key=toBase64url(t.encrypted_key)),t.header&&(e.header=t.header),e}function decode$j(t){const e={ciphertext:toBase64url(t.ciphertext),protected:toBase64url(t.protected),iv:toBase64url(t.iv),tag:toBase64url(t.tag)};return t.aad&&(e.aad=toBase64url(t.aad)),t.recipients&&(e.recipients=t.recipients.map(decodeRecipient)),t.unprotected&&(e.unprotected=t.unprotected),e}const name$3="dag-jose",code$3=133;function isDagJWS(t){return"payload"in t&&typeof t.payload=="string"&&"signatures"in t&&Array.isArray(t.signatures)}function isEncodedJWS(t){return"payload"in t&&t.payload instanceof Uint8Array&&"signatures"in t&&Array.isArray(t.signatures)}function isEncodedJWE(t){return"ciphertext"in t&&t.ciphertext instanceof Uint8Array&&"iv"in t&&t.iv instanceof Uint8Array&&"protected"in t&&t.protected instanceof Uint8Array&&"tag"in t&&t.tag instanceof Uint8Array}function isDagJWE(t){return"ciphertext"in t&&typeof t.ciphertext=="string"&&"iv"in t&&typeof t.iv=="string"&&"protected"in t&&typeof t.protected=="string"&&"tag"in t&&typeof t.tag=="string"}function toGeneral(t){if(typeof t=="string"){const e=t.split(".");if(e.length===3)return fromSplit$1(e);if(e.length===5)return fromSplit(e);throw new Error("Not a valid JOSE string")}if(isDagJWS(t)||isDagJWE(t))return t;throw new Error("Not a valid unencoded JOSE object")}function encode$e(t){typeof t=="string"&&(t=toGeneral(t));let e;if(isDagJWS(t))e=encode$g(t);else if(isDagJWE(t))e=encode$f(t);else throw new Error("Not a valid JOSE object");return new Uint8Array(encode$n(e))}function decode$i(t){let e;try{e=decode$v(t)}catch{throw new Error("Not a valid DAG-JOSE object")}if(isEncodedJWS(e))return decode$k(e);if(isEncodedJWE(e))return decode$j(e);throw new Error("Not a valid DAG-JOSE object")}const dagJOSE=Object.freeze(Object.defineProperty({__proto__:null,code:code$3,decode:decode$i,encode:encode$e,name:name$3,toGeneral},Symbol.toStringTag,{value:"Module"})),code$2=0,name$2="identity",encode$d=coerce$4,digest=t=>create$5(code$2,encode$d(t)),identity$4={code:code$2,name:name$2,encode:encode$d,digest},identity$5=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$4},Symbol.toStringTag,{value:"Module"})),identity$3=from$5({prefix:"\0",name:"identity",encode:t=>toString$6(t),decode:t=>fromString$6(t)}),identityBase$3=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$3},Symbol.toStringTag,{value:"Module"})),base2$6=rfc4648$4({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$7=Object.freeze(Object.defineProperty({__proto__:null,base2:base2$6},Symbol.toStringTag,{value:"Module"})),base8$6=rfc4648$4({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$7=Object.freeze(Object.defineProperty({__proto__:null,base8:base8$6},Symbol.toStringTag,{value:"Module"})),base10$6=baseX$4({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$7=Object.freeze(Object.defineProperty({__proto__:null,base10:base10$6},Symbol.toStringTag,{value:"Module"})),base16$6=rfc4648$4({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper$3=rfc4648$4({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$7=Object.freeze(Object.defineProperty({__proto__:null,base16:base16$6,base16upper:base16upper$3},Symbol.toStringTag,{value:"Module"})),base36$6=baseX$4({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper$3=baseX$4({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$7=Object.freeze(Object.defineProperty({__proto__:null,base36:base36$6,base36upper:base36upper$3},Symbol.toStringTag,{value:"Module"})),alphabet$3=Array.from(""),alphabetBytesToChars$3=alphabet$3.reduce((t,e,r)=>(t[r]=e,t),[]),alphabetCharsToBytes$3=alphabet$3.reduce((t,e,r)=>(t[e.codePointAt(0)]=r,t),[]);function encode$c(t){return t.reduce((e,r)=>(e+=alphabetBytesToChars$3[r],e),"")}function decode$h(t){const e=[];for(const r of t){const n=alphabetCharsToBytes$3[r.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${r}`);e.push(n)}return new Uint8Array(e)}const base256emoji$6=from$5({prefix:"",name:"base256emoji",encode:encode$c,decode:decode$h}),base256emoji$7=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:base256emoji$6},Symbol.toStringTag,{value:"Module"})),from$4=({name:t,code:e,encode:r})=>new Hasher(t,e,r);class Hasher{constructor(e,r,n){this.name=e,this.code=r,this.encode=n}digest(e){if(e instanceof Uint8Array){const r=this.encode(e);return r instanceof Uint8Array?create$5(this.code,r):r.then(n=>create$5(this.code,n))}else throw Error("Unknown type, must be binary type")}}const sha=t=>async e=>new Uint8Array(await crypto.subtle.digest(t,e)),sha256=from$4({name:"sha2-256",code:18,encode:sha("SHA-256")}),sha512=from$4({name:"sha2-512",code:19,encode:sha("SHA-512")}),sha2=Object.freeze(Object.defineProperty({__proto__:null,sha256,sha512},Symbol.toStringTag,{value:"Module"})),name$1="raw",code$1=85,encode$b=t=>coerce$4(t),decode$g=t=>coerce$4(t),raw=Object.freeze(Object.defineProperty({__proto__:null,code:code$1,decode:decode$g,encode:encode$b,name:name$1},Symbol.toStringTag,{value:"Module"})),textEncoder=new TextEncoder,textDecoder=new TextDecoder,name="json",code=512,encode$a=t=>textEncoder.encode(JSON.stringify(t)),decode$f=t=>JSON.parse(textDecoder.decode(t)),json=Object.freeze(Object.defineProperty({__proto__:null,code,decode:decode$f,encode:encode$a,name},Symbol.toStringTag,{value:"Module"})),bases$3={...identityBase$3,...base2$7,...base8$7,...base10$7,...base16$7,...base32$8,...base36$7,...base58$3,...base64$a,...base256emoji$7},hashes={...sha2,...identity$5},codecs$1={raw,json};class Parser{constructor(){P(this,"index",0);P(this,"input","")}new(e){return this.index=0,this.input=e,this}readAtomically(e){const r=this.index,n=e();return n===void 0&&(this.index=r),n}parseWith(e){const r=e();if(this.index===this.input.length)return r}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const r=this.readChar();if(r===e)return r})}readSeparator(e,r,n){return this.readAtomically(()=>{if(!(r>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,r,n,o){return this.readAtomically(()=>{let s=0,a=0;const i=this.peekChar();if(i===void 0)return;const c=i==="0",d=2**(8*o)-1;for(;;){const l=this.readAtomically(()=>{const f=this.readChar();if(f===void 0)return;const p=Number.parseInt(f,e);if(!Number.isNaN(p))return p});if(l===void 0)break;if(s*=e,s+=l,s>d||(a+=1,r!==void 0&&a>r))return}if(a!==0)return!n&&c&&a>1?void 0:s})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let r=0;r<e.length;r++){const n=this.readSeparator(".",r,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[r]=n}return e})}readIPv6Addr(){const e=r=>{for(let n=0;n<r.length/2;n++){const o=n*2;if(n<r.length-3){const a=this.readSeparator(":",n,()=>this.readIPv4Addr());if(a!==void 0)return r[o]=a[0],r[o+1]=a[1],r[o+2]=a[2],r[o+3]=a[3],[o+4,!0]}const s=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(s===void 0)return[o,!1];r[o]=s>>8,r[o+1]=s&255}return[r.length,!1]};return this.readAtomically(()=>{const r=new Uint8Array(16),[n,o]=e(r);if(n===16)return r;if(o||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const s=new Uint8Array(14),a=16-(n+2),[i]=e(s.subarray(0,a));return r.set(s.subarray(0,i),16-i),r})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const MAX_IPV6_LENGTH=45,MAX_IPV4_LENGTH=15,parser=new Parser;function parseIPv4(t){if(!(t.length>MAX_IPV4_LENGTH))return parser.new(t).parseWith(()=>parser.readIPv4Addr())}function parseIPv6(t){if(t.includes("%")&&(t=t.split("%")[0]),!(t.length>MAX_IPV6_LENGTH))return parser.new(t).parseWith(()=>parser.readIPv6Addr())}function parseIP(t,e=!1){if(t.includes("%")&&(t=t.split("%")[0]),t.length>MAX_IPV6_LENGTH)return;const r=parser.new(t).parseWith(()=>parser.readIPAddr());if(r)return e&&r.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,r[0],r[1],r[2],r[3]]):r}function isIPv4(t){return!!parseIPv4(t)}function isIPv6(t){return!!parseIPv6(t)}function isIP(t){return!!parseIP(t)}function base$3(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var s=t.charAt(o),a=s.charCodeAt(0);if(r[a]!==255)throw new TypeError(s+" is ambiguous");r[a]=o}var i=t.length,c=t.charAt(0),d=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var h=0,S=0,y=0,m=u.length;y!==m&&u[y]===0;)y++,h++;for(var $=(m-y)*l+1>>>0,b=new Uint8Array($);y!==m;){for(var w=u[y],T=0,g=$-1;(w!==0||T<S)&&g!==-1;g--,T++)w+=256*b[g]>>>0,b[g]=w%i>>>0,w=w/i>>>0;if(w!==0)throw new Error("Non-zero carry");S=T,y++}for(var E=$-S;E!==$&&b[E]===0;)E++;for(var C=c.repeat(h);E<$;++E)C+=t.charAt(b[E]);return C}function p(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var h=0;if(u[h]!==" "){for(var S=0,y=0;u[h]===c;)S++,h++;for(var m=(u.length-h)*d+1>>>0,$=new Uint8Array(m);u[h];){var b=r[u.charCodeAt(h)];if(b===255)return;for(var w=0,T=m-1;(b!==0||w<y)&&T!==-1;T--,w++)b+=i*$[T]>>>0,$[T]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");y=w,h++}if(u[h]!==" "){for(var g=m-y;g!==m&&$[g]===0;)g++;for(var E=new Uint8Array(S+(m-g)),C=S;g!==m;)E[C++]=$[g++];return E}}}function v(u){var h=p(u);if(h)return h;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:p,decode:v}}var src$4=base$3,_brrp__multiformats_scope_baseX$3=src$4;const coerce$3=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},fromString$5=t=>new TextEncoder().encode(t),toString$5=t=>new TextDecoder().decode(t);let Encoder$3=class{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Decoder$3=class{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$3(this,e)}},ComposedDecoder$3=class{constructor(e){this.decoders=e}or(e){return or$3(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$3=(t,e)=>new ComposedDecoder$3({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});let Codec$3=class{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$3(e,r,n),this.decoder=new Decoder$3(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const from$3=({name:t,prefix:e,encode:r,decode:n})=>new Codec$3(t,e,r,n),baseX$3=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$3(r,e);return from$3({prefix:t,name:e,encode:n,decode:s=>coerce$3(o(s))})},decode$e=(t,e,r,n)=>{const o={};for(let l=0;l<e.length;++l)o[e[l]]=l;let s=t.length;for(;t[s-1]==="=";)--s;const a=new Uint8Array(s*r/8|0);let i=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[t[l]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<r|f,i+=r,i>=8&&(i-=8,a[d++]=255&c>>i)}if(i>=r||255&c<<8-i)throw new SyntaxError("Unexpected end of data");return a},encode$9=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let s="",a=0,i=0;for(let c=0;c<t.length;++c)for(i=i<<8|t[c],a+=8;a>r;)a-=r,s+=e[o&i>>a];if(a&&(s+=e[o&i<<r-a]),n)for(;s.length*r&7;)s+="=";return s},rfc4648$3=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$3({prefix:e,name:t,encode(o){return encode$9(o,n,r)},decode(o){return decode$e(o,n,r,t)}}),base10$4=baseX$3({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$5=Object.freeze(Object.defineProperty({__proto__:null,base10:base10$4},Symbol.toStringTag,{value:"Module"})),base16$4=rfc4648$3({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper$2=rfc4648$3({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$5=Object.freeze(Object.defineProperty({__proto__:null,base16:base16$4,base16upper:base16upper$2},Symbol.toStringTag,{value:"Module"})),base2$4=rfc4648$3({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$5=Object.freeze(Object.defineProperty({__proto__:null,base2:base2$4},Symbol.toStringTag,{value:"Module"})),alphabet$2=Array.from(""),alphabetBytesToChars$2=alphabet$2.reduce((t,e,r)=>(t[r]=e,t),[]),alphabetCharsToBytes$2=alphabet$2.reduce((t,e,r)=>(t[e.codePointAt(0)]=r,t),[]);function encode$8(t){return t.reduce((e,r)=>(e+=alphabetBytesToChars$2[r],e),"")}function decode$d(t){const e=[];for(const r of t){const n=alphabetCharsToBytes$2[r.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${r}`);e.push(n)}return new Uint8Array(e)}const base256emoji$4=from$3({prefix:"",name:"base256emoji",encode:encode$8,decode:decode$d}),base256emoji$5=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:base256emoji$4},Symbol.toStringTag,{value:"Module"})),base32$5=rfc4648$3({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper$2=rfc4648$3({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad$2=rfc4648$3({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper$2=rfc4648$3({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex$2=rfc4648$3({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper$2=rfc4648$3({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad$2=rfc4648$3({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper$2=rfc4648$3({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z$2=rfc4648$3({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$6=Object.freeze(Object.defineProperty({__proto__:null,base32:base32$5,base32hex:base32hex$2,base32hexpad:base32hexpad$2,base32hexpadupper:base32hexpadupper$2,base32hexupper:base32hexupper$2,base32pad:base32pad$2,base32padupper:base32padupper$2,base32upper:base32upper$2,base32z:base32z$2},Symbol.toStringTag,{value:"Module"})),base36$4=baseX$3({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper$2=baseX$3({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$5=Object.freeze(Object.defineProperty({__proto__:null,base36:base36$4,base36upper:base36upper$2},Symbol.toStringTag,{value:"Module"})),base58btc$3=baseX$3({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr$2=baseX$3({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58$2=Object.freeze(Object.defineProperty({__proto__:null,base58btc:base58btc$3,base58flickr:base58flickr$2},Symbol.toStringTag,{value:"Module"})),base64$7=rfc4648$3({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad$2=rfc4648$3({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url$2=rfc4648$3({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad$2=rfc4648$3({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$8=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$7,base64pad:base64pad$2,base64url:base64url$2,base64urlpad:base64urlpad$2},Symbol.toStringTag,{value:"Module"})),base8$4=rfc4648$3({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$5=Object.freeze(Object.defineProperty({__proto__:null,base8:base8$4},Symbol.toStringTag,{value:"Module"})),identity$2=from$3({prefix:"\0",name:"identity",encode:t=>toString$5(t),decode:t=>fromString$5(t)}),identityBase$2=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$2},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const bases$2={...identityBase$2,...base2$5,...base8$5,...base10$5,...base16$5,...base32$6,...base36$5,...base58$2,...base64$8,...base256emoji$5};function asUint8Array$1(t){return globalThis.Buffer!=null?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t}function allocUnsafe$1(t=0){var e;return((e=globalThis.Buffer)==null?void 0:e.allocUnsafe)!=null?asUint8Array$1(globalThis.Buffer.allocUnsafe(t)):new Uint8Array(t)}function createCodec$1(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}const string$1=createCodec$1("utf8","u",t=>"u"+new TextDecoder("utf8").decode(t),t=>new TextEncoder().encode(t.substring(1))),ascii$1=createCodec$1("ascii","a",t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},t=>{t=t.substring(1);const e=allocUnsafe$1(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}),BASES$1={utf8:string$1,"utf-8":string$1,hex:bases$2.base16,latin1:ascii$1,ascii:ascii$1,binary:ascii$1,...bases$2};function toString$4(t,e="utf8"){const r=BASES$1[e];if(r==null)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(t.buffer,t.byteOffset,t.byteLength).toString("utf8"):r.encoder.encode(t).substring(1)}const isV4=isIPv4,isV6=isIPv6,toBytes$1=function(t){let e=0;if(t=t.toString().trim(),isV4(t)){const r=new Uint8Array(e+4);return t.split(/\./g).forEach(n=>{r[e++]=parseInt(n,10)&255}),r}if(isV6(t)){const r=t.split(":",8);let n;for(n=0;n<r.length;n++){const s=isV4(r[n]);let a;s&&(a=toBytes$1(r[n]),r[n]=toString$4(a.slice(0,2),"base16")),a!=null&&++n<8&&r.splice(n,0,toString$4(a.slice(2,4),"base16"))}if(r[0]==="")for(;r.length<8;)r.unshift("0");else if(r[r.length-1]==="")for(;r.length<8;)r.push("0");else if(r.length<8){for(n=0;n<r.length&&r[n]!=="";n++);const s=[n,1];for(n=9-r.length;n>0;n--)s.push("0");r.splice.apply(r,s)}const o=new Uint8Array(e+16);for(n=0;n<r.length;n++){const s=parseInt(r[n],16);o[e++]=s>>8&255,o[e++]=s&255}return o}throw new Error("invalid ip address")},toString$3=function(t,e=0,r){e=~~e,r=r??t.length-e;const n=new DataView(t.buffer);if(r===4){const o=[];for(let s=0;s<r;s++)o.push(t[e+s]);return o.join(".")}if(r===16){const o=[];for(let s=0;s<r;s+=2)o.push(n.getUint16(e+s).toString(16));return o.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},V$1=-1,names={},codes={},table=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,V$1,"ip6zone"],[43,8,"ipcidr"],[53,V$1,"dns",!0],[54,V$1,"dns4",!0],[55,V$1,"dns6",!0],[56,V$1,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc"],[281,0,"webrtc-w3c"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,V$1,"unix",!1,!0],[421,V$1,"ipfs"],[421,V$1,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,V$1,"garlic64"],[448,0,"tls"],[449,V$1,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,V$1,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,V$1,"memory"]];table.forEach(t=>{const e=createProtocol(...t);codes[e.code]=e,names[e.name]=e});function createProtocol(t,e,r,n,o){return{code:t,size:e,name:r,resolvable:!!n,path:!!o}}function getProtocol(t){if(typeof t=="number"){if(codes[t]!=null)return codes[t];throw new Error(`no protocol with code: ${t}`)}else if(typeof t=="string"){if(names[t]!=null)return names[t];throw new Error(`no protocol with name: ${t}`)}throw new Error(`invalid protocol id type: ${typeof t}`)}var encode_1$2=encode$7,MSB$4=128,MSBALL$2=-128,INT$2=Math.pow(2,31);function encode$7(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT$2;)e[r++]=t&255|MSB$4,t/=128;for(;t&MSBALL$2;)e[r++]=t&255|MSB$4,t>>>=7;return e[r]=t|0,encode$7.bytes=r-n+1,e}var decode$c=read$2,MSB$1$2=128,REST$1$1=127;function read$2(t,n){var r=0,n=n||0,o=0,s=n,a,i=t.length;do{if(s>=i)throw read$2.bytes=0,new RangeError("Could not decode varint");a=t[s++],r+=o<28?(a&REST$1$1)<<o:(a&REST$1$1)*Math.pow(2,o),o+=7}while(a>=MSB$1$2);return read$2.bytes=s-n,r}var N1$3=Math.pow(2,7),N2$3=Math.pow(2,14),N3$3=Math.pow(2,21),N4$3=Math.pow(2,28),N5$3=Math.pow(2,35),N6$3=Math.pow(2,42),N7$3=Math.pow(2,49),N8$2=Math.pow(2,56),N9$2=Math.pow(2,63),length$2=function(t){return t<N1$3?1:t<N2$3?2:t<N3$3?3:t<N4$3?4:t<N5$3?5:t<N6$3?6:t<N7$3?7:t<N8$2?8:t<N9$2?9:10},varint$3={encode:encode_1$2,decode:decode$c,encodingLength:length$2},_brrp_varint$1=varint$3;const decode$b=(t,e=0)=>[_brrp_varint$1.decode(t,e),_brrp_varint$1.decode.bytes],encodeTo$1=(t,e,r=0)=>(_brrp_varint$1.encode(t,e,r),e),encodingLength$2=t=>_brrp_varint$1.encodingLength(t),equals$5=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},coerce$2=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},fromString$4=t=>new TextEncoder().encode(t),toString$2=t=>new TextDecoder().decode(t),create$4=(t,e)=>{const r=e.byteLength,n=encodingLength$2(t),o=n+encodingLength$2(r),s=new Uint8Array(o+r);return encodeTo$1(t,s,0),encodeTo$1(r,s,n),s.set(e,o),new Digest$1(t,r,e,s)},decode$a=t=>{const e=coerce$2(t),[r,n]=decode$b(e),[o,s]=decode$b(e.subarray(n)),a=e.subarray(n+s);if(a.byteLength!==o)throw new Error("Incorrect length");return new Digest$1(r,o,a,e)},equals$4=(t,e)=>{if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&equals$5(t.bytes,r.bytes)}};let Digest$1=class{constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}};function base$2(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var s=t.charAt(o),a=s.charCodeAt(0);if(r[a]!==255)throw new TypeError(s+" is ambiguous");r[a]=o}var i=t.length,c=t.charAt(0),d=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var h=0,S=0,y=0,m=u.length;y!==m&&u[y]===0;)y++,h++;for(var $=(m-y)*l+1>>>0,b=new Uint8Array($);y!==m;){for(var w=u[y],T=0,g=$-1;(w!==0||T<S)&&g!==-1;g--,T++)w+=256*b[g]>>>0,b[g]=w%i>>>0,w=w/i>>>0;if(w!==0)throw new Error("Non-zero carry");S=T,y++}for(var E=$-S;E!==$&&b[E]===0;)E++;for(var C=c.repeat(h);E<$;++E)C+=t.charAt(b[E]);return C}function p(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var h=0;if(u[h]!==" "){for(var S=0,y=0;u[h]===c;)S++,h++;for(var m=(u.length-h)*d+1>>>0,$=new Uint8Array(m);u[h];){var b=r[u.charCodeAt(h)];if(b===255)return;for(var w=0,T=m-1;(b!==0||w<y)&&T!==-1;T--,w++)b+=i*$[T]>>>0,$[T]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");y=w,h++}if(u[h]!==" "){for(var g=m-y;g!==m&&$[g]===0;)g++;for(var E=new Uint8Array(S+(m-g)),C=S;g!==m;)E[C++]=$[g++];return E}}}function v(u){var h=p(u);if(h)return h;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:p,decode:v}}var src$3=base$2,_brrp__multiformats_scope_baseX$2=src$3;let Encoder$2=class{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Decoder$2=class{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$2(this,e)}},ComposedDecoder$2=class{constructor(e){this.decoders=e}or(e){return or$2(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$2=(t,e)=>new ComposedDecoder$2({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});let Codec$2=class{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$2(e,r,n),this.decoder=new Decoder$2(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const from$2=({name:t,prefix:e,encode:r,decode:n})=>new Codec$2(t,e,r,n),baseX$2=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$2(r,e);return from$2({prefix:t,name:e,encode:n,decode:s=>coerce$2(o(s))})},decode$9=(t,e,r,n)=>{const o={};for(let l=0;l<e.length;++l)o[e[l]]=l;let s=t.length;for(;t[s-1]==="=";)--s;const a=new Uint8Array(s*r/8|0);let i=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[t[l]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<r|f,i+=r,i>=8&&(i-=8,a[d++]=255&c>>i)}if(i>=r||255&c<<8-i)throw new SyntaxError("Unexpected end of data");return a},encode$6=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let s="",a=0,i=0;for(let c=0;c<t.length;++c)for(i=i<<8|t[c],a+=8;a>r;)a-=r,s+=e[o&i>>a];if(a&&(s+=e[o&i<<r-a]),n)for(;s.length*r&7;)s+="=";return s},rfc4648$2=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$2({prefix:e,name:t,encode(o){return encode$6(o,n,r)},decode(o){return decode$9(o,n,r,t)}}),base58btc$2=baseX$2({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr$1=baseX$2({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58$1=Object.freeze(Object.defineProperty({__proto__:null,base58btc:base58btc$2,base58flickr:base58flickr$1},Symbol.toStringTag,{value:"Module"})),base32$3=rfc4648$2({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper$1=rfc4648$2({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad$1=rfc4648$2({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper$1=rfc4648$2({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex$1=rfc4648$2({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper$1=rfc4648$2({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad$1=rfc4648$2({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper$1=rfc4648$2({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z$1=rfc4648$2({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$4=Object.freeze(Object.defineProperty({__proto__:null,base32:base32$3,base32hex:base32hex$1,base32hexpad:base32hexpad$1,base32hexpadupper:base32hexpadupper$1,base32hexupper:base32hexupper$1,base32pad:base32pad$1,base32padupper:base32padupper$1,base32upper:base32upper$1,base32z:base32z$1},Symbol.toStringTag,{value:"Module"})),format$4=(t,e)=>{const{bytes:r,version:n}=t;switch(n){case 0:return toStringV0$1(r,baseCache$1(t),e||base58btc$2.encoder);default:return toStringV1$1(r,baseCache$1(t),e||base32$3.encoder)}},cache$1=new WeakMap,baseCache$1=t=>{const e=cache$1.get(t);if(e==null){const r=new Map;return cache$1.set(t,r),r}return e};let CID$1=class O{constructor(e,r,n,o){this.code=r,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE$1)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE$1)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return O.createV0(r)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create$4(e,r);return O.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return O.equals(this,e)}static equals(e,r){const n=r;return n&&e.code===n.code&&e.version===n.version&&equals$4(e.multihash,n.multihash)}toString(e){return format$4(this,e)}toJSON(){return{"/":format$4(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const r=e;if(r instanceof O)return r;if(r["/"]!=null&&r["/"]===r.bytes||r.asCID===r){const{version:n,code:o,multihash:s,bytes:a}=r;return new O(n,o,s,a||encodeCID$2(n,o,s.bytes))}else if(r[cidSymbol$1]===!0){const{version:n,multihash:o,code:s}=r,a=decode$a(o);return O.create(n,s,a)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(r!==DAG_PB_CODE$1)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$1}) block encoding`);return new O(e,r,n,n.bytes)}case 1:{const o=encodeCID$2(e,r,n.bytes);return new O(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return O.create(0,DAG_PB_CODE$1,e)}static createV1(e,r){return O.create(1,e,r)}static decode(e){const[r,n]=O.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=O.inspectBytes(e),n=r.size-r.multihashSize,o=coerce$2(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");const s=o.subarray(r.multihashSize-r.digestSize),a=new Digest$1(r.multihashCode,r.digestSize,s,o);return[r.version===0?O.createV0(a):O.createV1(r.codec,a),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[f,p]=decode$b(e.subarray(r));return r+=p,f};let o=n(),s=DAG_PB_CODE$1;if(o===18?(o=0,r=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const a=r,i=n(),c=n(),d=r+c,l=d-a;return{version:o,codec:s,multihashCode:i,digestSize:c,multihashSize:l,size:d}}static parse(e,r){const[n,o]=parseCIDtoBytes$1(e,r),s=O.decode(o);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return baseCache$1(s).set(n,e),s}};const parseCIDtoBytes$1=(t,e)=>{switch(t[0]){case"Q":{const r=e||base58btc$2;return[base58btc$2.prefix,r.decode(`${base58btc$2.prefix}${t}`)]}case base58btc$2.prefix:{const r=e||base58btc$2;return[base58btc$2.prefix,r.decode(t)]}case base32$3.prefix:{const r=e||base32$3;return[base32$3.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},toStringV0$1=(t,e,r)=>{const{prefix:n}=r;if(n!==base58btc$2.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=e.get(n);if(o==null){const s=r.encode(t).slice(1);return e.set(n,s),s}else return o},toStringV1$1=(t,e,r)=>{const{prefix:n}=r,o=e.get(n);if(o==null){const s=r.encode(t);return e.set(n,s),s}else return o},DAG_PB_CODE$1=112,SHA_256_CODE$1=18,encodeCID$2=(t,e,r)=>{const n=encodingLength$2(t),o=n+encodingLength$2(e),s=new Uint8Array(o+r.byteLength);return encodeTo$1(t,s,0),encodeTo$1(e,s,n),s.set(r,o),s},cidSymbol$1=Symbol.for("@ipld/js-cid/CID"),identity$1=from$2({prefix:"\0",name:"identity",encode:t=>toString$2(t),decode:t=>fromString$4(t)}),identityBase$1=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$1},Symbol.toStringTag,{value:"Module"})),base2$2=rfc4648$2({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$3=Object.freeze(Object.defineProperty({__proto__:null,base2:base2$2},Symbol.toStringTag,{value:"Module"})),base8$2=rfc4648$2({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$3=Object.freeze(Object.defineProperty({__proto__:null,base8:base8$2},Symbol.toStringTag,{value:"Module"})),base10$2=baseX$2({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$3=Object.freeze(Object.defineProperty({__proto__:null,base10:base10$2},Symbol.toStringTag,{value:"Module"})),base16$2=rfc4648$2({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper$1=rfc4648$2({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$3=Object.freeze(Object.defineProperty({__proto__:null,base16:base16$2,base16upper:base16upper$1},Symbol.toStringTag,{value:"Module"})),base36$2=baseX$2({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper$1=baseX$2({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$3=Object.freeze(Object.defineProperty({__proto__:null,base36:base36$2,base36upper:base36upper$1},Symbol.toStringTag,{value:"Module"})),base64$5=rfc4648$2({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad$1=rfc4648$2({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url$1=rfc4648$2({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad$1=rfc4648$2({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$6=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$5,base64pad:base64pad$1,base64url:base64url$1,base64urlpad:base64urlpad$1},Symbol.toStringTag,{value:"Module"})),alphabet$1=Array.from(""),alphabetBytesToChars$1=alphabet$1.reduce((t,e,r)=>(t[r]=e,t),[]),alphabetCharsToBytes$1=alphabet$1.reduce((t,e,r)=>(t[e.codePointAt(0)]=r,t),[]);function encode$5(t){return t.reduce((e,r)=>(e+=alphabetBytesToChars$1[r],e),"")}function decode$8(t){const e=[];for(const r of t){const n=alphabetCharsToBytes$1[r.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${r}`);e.push(n)}return new Uint8Array(e)}const base256emoji$2=from$2({prefix:"",name:"base256emoji",encode:encode$5,decode:decode$8}),base256emoji$3=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:base256emoji$2},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const bases$1={...identityBase$1,...base2$3,...base8$3,...base10$3,...base16$3,...base32$4,...base36$3,...base58$1,...base64$6,...base256emoji$3};var encode_1$1=encode$4,MSB$3=128,MSBALL$1=-128,INT$1=Math.pow(2,31);function encode$4(t,e,r){if(Number.MAX_SAFE_INTEGER&&t>Number.MAX_SAFE_INTEGER)throw encode$4.bytes=0,new RangeError("Could not encode varint");e=e||[],r=r||0;for(var n=r;t>=INT$1;)e[r++]=t&255|MSB$3,t/=128;for(;t&MSBALL$1;)e[r++]=t&255|MSB$3,t>>>=7;return e[r]=t|0,encode$4.bytes=r-n+1,e}var decode$7=read$1,MSB$2=128,REST$2=127;function read$1(t,n){var r=0,n=n||0,o=0,s=n,a,i=t.length;do{if(s>=i||o>49)throw read$1.bytes=0,new RangeError("Could not decode varint");a=t[s++],r+=o<28?(a&REST$2)<<o:(a&REST$2)*Math.pow(2,o),o+=7}while(a>=MSB$2);return read$1.bytes=s-n,r}var N1$2=Math.pow(2,7),N2$2=Math.pow(2,14),N3$2=Math.pow(2,21),N4$2=Math.pow(2,28),N5$2=Math.pow(2,35),N6$2=Math.pow(2,42),N7$2=Math.pow(2,49),N8$1=Math.pow(2,56),N9$1=Math.pow(2,63),length$1=function(t){return t<N1$2?1:t<N2$2?2:t<N3$2?3:t<N4$2?4:t<N5$2?5:t<N6$2?6:t<N7$2?7:t<N8$1?8:t<N9$1?9:10},varint$1={encode:encode_1$1,decode:decode$7,encodingLength:length$1};const varint$2=getDefaultExportFromCjs(varint$1);function fromString$3(t,e="utf8"){const r=BASES$1[e];if(r==null)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array$1(globalThis.Buffer.from(t,"utf-8")):r.decoder.decode(`${r.prefix}${t}`)}function concat$1(t,e){e==null&&(e=t.reduce((o,s)=>o+s.length,0));const r=allocUnsafe$1(e);let n=0;for(const o of t)r.set(o,n),n+=o.length;return asUint8Array$1(r)}function convertToString(t,e){switch(getProtocol(t).code){case 4:case 41:return bytes2ip(e);case 42:return bytes2str(e);case 6:case 273:case 33:case 132:return bytes2port$1(e).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return bytes2str(e);case 421:return bytes2mh(e);case 444:return bytes2onion$1(e);case 445:return bytes2onion$1(e);case 466:return bytes2mb$1(e);default:return toString$4(e,"base16")}}function convertToBytes(t,e){switch(getProtocol(t).code){case 4:return ip2bytes(e);case 41:return ip2bytes(e);case 42:return str2bytes(e);case 6:case 273:case 33:case 132:return port2bytes$1(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return str2bytes(e);case 421:return mh2bytes(e);case 444:return onion2bytes$1(e);case 445:return onion32bytes$1(e);case 466:return mb2bytes$1(e);default:return fromString$3(e,"base16")}}const decoders$1=Object.values(bases$1).map(t=>t.decoder),anybaseDecoder$1=function(){let t=decoders$1[0].or(decoders$1[1]);return decoders$1.slice(2).forEach(e=>t=t.or(e)),t}();function ip2bytes(t){if(!isIP(t))throw new Error("invalid ip address");return toBytes$1(t)}function bytes2ip(t){const e=toString$3(t,0,t.length);if(e==null)throw new Error("ipBuff is required");if(!isIP(e))throw new Error("invalid ip address");return e}function port2bytes$1(t){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,t),new Uint8Array(e)}function bytes2port$1(t){return new DataView(t.buffer).getUint16(t.byteOffset)}function str2bytes(t){const e=fromString$3(t),r=Uint8Array.from(varint$2.encode(e.length));return concat$1([r,e],r.length+e.length)}function bytes2str(t){const e=varint$2.decode(t);if(t=t.slice(varint$2.decode.bytes),t.length!==e)throw new Error("inconsistent lengths");return toString$4(t)}function mh2bytes(t){let e;t[0]==="Q"||t[0]==="1"?e=decode$a(base58btc$2.decode(`z${t}`)).bytes:e=CID$1.parse(t).multihash.bytes;const r=Uint8Array.from(varint$2.encode(e.length));return concat$1([r,e],r.length+e.length)}function mb2bytes$1(t){const e=anybaseDecoder$1.decode(t),r=Uint8Array.from(varint$2.encode(e.length));return concat$1([r,e],r.length+e.length)}function bytes2mb$1(t){const e=varint$2.decode(t),r=t.slice(varint$2.decode.bytes);if(r.length!==e)throw new Error("inconsistent lengths");return"u"+toString$4(r,"base64url")}function bytes2mh(t){const e=varint$2.decode(t),r=t.slice(varint$2.decode.bytes);if(r.length!==e)throw new Error("inconsistent lengths");return toString$4(r,"base58btc")}function onion2bytes$1(t){const e=t.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const r=base32$3.decode("b"+e[0]),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const o=port2bytes$1(n);return concat$1([r,o],r.length+o.length)}function onion32bytes$1(t){const e=t.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const r=base32$3.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const o=port2bytes$1(n);return concat$1([r,o],r.length+o.length)}function bytes2onion$1(t){const e=t.slice(0,t.length-2),r=t.slice(t.length-2),n=toString$4(e,"base32"),o=bytes2port$1(r);return`${n}:${o}`}function stringToStringTuples(t){const e=[],r=t.split("/").slice(1);if(r.length===1&&r[0]==="")return[];for(let n=0;n<r.length;n++){const o=r[n],s=getProtocol(o);if(s.size===0){e.push([o]);continue}if(n++,n>=r.length)throw ParseError("invalid address: "+t);if(s.path===!0){e.push([o,cleanPath(r.slice(n).join("/"))]);break}e.push([o,r[n]])}return e}function stringTuplesToString(t){const e=[];return t.map(r=>{const n=protoFromTuple(r);return e.push(n.name),r.length>1&&r[1]!=null&&e.push(r[1]),null}),cleanPath(e.join("/"))}function stringTuplesToTuples(t){return t.map(e=>{Array.isArray(e)||(e=[e]);const r=protoFromTuple(e);return e.length>1?[r.code,convertToBytes(r.code,e[1])]:[r.code]})}function tuplesToStringTuples(t){return t.map(e=>{const r=protoFromTuple(e);return e[1]!=null?[r.code,convertToString(r.code,e[1])]:[r.code]})}function tuplesToBytes(t){return fromBytes(concat$1(t.map(e=>{const r=protoFromTuple(e);let n=Uint8Array.from(varint$2.encode(r.code));return e.length>1&&e[1]!=null&&(n=concat$1([n,e[1]])),n})))}function sizeForAddr$1(t,e){return t.size>0?t.size/8:t.size===0?0:varint$2.decode(e)+(varint$2.decode.bytes??0)}function bytesToTuples(t){const e=[];let r=0;for(;r<t.length;){const n=varint$2.decode(t,r),o=varint$2.decode.bytes??0,s=getProtocol(n),a=sizeForAddr$1(s,t.slice(r+o));if(a===0){e.push([n]),r+=o;continue}const i=t.slice(r+o,r+o+a);if(r+=a+o,r>t.length)throw ParseError("Invalid address Uint8Array: "+toString$4(t,"base16"));e.push([n,i])}return e}function bytesToString$1(t){const e=bytesToTuples(t),r=tuplesToStringTuples(e);return stringTuplesToString(r)}function stringToBytes$1(t){t=cleanPath(t);const e=stringToStringTuples(t),r=stringTuplesToTuples(e);return tuplesToBytes(r)}function fromString$2(t){return stringToBytes$1(t)}function fromBytes(t){const e=validateBytes(t);if(e!=null)throw e;return Uint8Array.from(t)}function validateBytes(t){try{bytesToTuples(t)}catch(e){return e}}function cleanPath(t){return"/"+t.trim().split("/").filter(e=>e).join("/")}function ParseError(t){return new Error("Error parsing address: "+t)}function protoFromTuple(t){return getProtocol(t[0])}function assign(t,e){for(const r in e)Object.defineProperty(t,r,{value:e[r],enumerable:!0,configurable:!0});return t}function createError(t,e,r){if(!t||typeof t=="string")throw new TypeError("Please pass an Error to err-code");r||(r={}),typeof e=="object"&&(r=e,e=""),e&&(r.code=e);try{return assign(t,r)}catch{r.message=t.message,r.stack=t.stack;const o=function(){};return o.prototype=Object.create(Object.getPrototypeOf(t)),assign(new o,r)}}var errCode=createError;const errCode$1=getDefaultExportFromCjs(errCode);function equals$3(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}var __classPrivateFieldGet=function(t,e,r,n){if(r==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?t!==e||!n:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return r==="m"?n:r==="a"?n.call(t):n?n.value:e.get(t)},__classPrivateFieldSet=function(t,e,r,n,o){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!o)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?t!==e||!o:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?o.call(t,r):o?o.value=r:e.set(t,r),r},_DefaultMultiaddr_string,_DefaultMultiaddr_tuples,_DefaultMultiaddr_stringTuples,_a;const inspect$2=Symbol.for("nodejs.util.inspect.custom"),DNS_CODES$1=[getProtocol("dns").code,getProtocol("dns4").code,getProtocol("dns6").code,getProtocol("dnsaddr").code],resolvers$1=new Map,symbol$2=Symbol.for("@multiformats/js-multiaddr/multiaddr");function isMultiaddr$1(t){return!!(t!=null&&t[symbol$2])}class DefaultMultiaddr{constructor(e){if(_DefaultMultiaddr_string.set(this,void 0),_DefaultMultiaddr_tuples.set(this,void 0),_DefaultMultiaddr_stringTuples.set(this,void 0),this[_a]=!0,e==null&&(e=""),e instanceof Uint8Array)this.bytes=fromBytes(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);this.bytes=fromString$2(e)}else if(isMultiaddr$1(e))this.bytes=fromBytes(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr")}toString(){return __classPrivateFieldGet(this,_DefaultMultiaddr_string,"f")==null&&__classPrivateFieldSet(this,_DefaultMultiaddr_string,bytesToString$1(this.bytes),"f"),__classPrivateFieldGet(this,_DefaultMultiaddr_string,"f")}toJSON(){return this.toString()}toOptions(){let e,r,n,o,s="";const a=getProtocol("tcp"),i=getProtocol("udp"),c=getProtocol("ip4"),d=getProtocol("ip6"),l=getProtocol("dns6"),f=getProtocol("ip6zone");for(const[v,u]of this.stringTuples())v===f.code&&(s=`%${u??""}`),DNS_CODES$1.includes(v)&&(r=a.name,o=443,n=`${u??""}${s}`,e=v===l.code?6:4),(v===a.code||v===i.code)&&(r=getProtocol(v).name,o=parseInt(u??"")),(v===c.code||v===d.code)&&(r=getProtocol(v).name,n=`${u??""}${s}`,e=v===d.code?6:4);if(e==null||r==null||n==null||o==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:r,port:o}}protos(){return this.protoCodes().map(e=>Object.assign({},getProtocol(e)))}protoCodes(){const e=[],r=this.bytes;let n=0;for(;n<r.length;){const o=varint$2.decode(r,n),s=varint$2.decode.bytes??0,a=getProtocol(o),i=sizeForAddr$1(a,r.slice(n+s));n+=i+s,e.push(o)}return e}protoNames(){return this.protos().map(e=>e.name)}tuples(){return __classPrivateFieldGet(this,_DefaultMultiaddr_tuples,"f")==null&&__classPrivateFieldSet(this,_DefaultMultiaddr_tuples,bytesToTuples(this.bytes),"f"),__classPrivateFieldGet(this,_DefaultMultiaddr_tuples,"f")}stringTuples(){return __classPrivateFieldGet(this,_DefaultMultiaddr_stringTuples,"f")==null&&__classPrivateFieldSet(this,_DefaultMultiaddr_stringTuples,tuplesToStringTuples(this.tuples()),"f"),__classPrivateFieldGet(this,_DefaultMultiaddr_stringTuples,"f")}encapsulate(e){return e=new DefaultMultiaddr(e),new DefaultMultiaddr(this.toString()+e.toString())}decapsulate(e){const r=e.toString(),n=this.toString(),o=n.lastIndexOf(r);if(o<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new DefaultMultiaddr(n.slice(0,o))}decapsulateCode(e){const r=this.tuples();for(let n=r.length-1;n>=0;n--)if(r[n][0]===e)return new DefaultMultiaddr(tuplesToBytes(r.slice(0,n)));return this}getPeerId(){try{const r=this.stringTuples().filter(n=>n[0]===names.ipfs.code).pop();if((r==null?void 0:r[1])!=null){const n=r[1];return n[0]==="Q"||n[0]==="1"?toString$4(base58btc$2.decode(`z${n}`),"base58btc"):toString$4(CID$1.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){let e=null;try{e=this.stringTuples().filter(r=>getProtocol(r[0]).path===!0)[0][1],e==null&&(e=null)}catch{e=null}return e}equals(e){return equals$3(this.bytes,e.bytes)}async resolve(e){const r=this.protos().find(s=>s.resolvable);if(r==null)return[this];const n=resolvers$1.get(r.name);if(n==null)throw errCode$1(new Error(`no available resolver for ${r.name}`),"ERR_NO_AVAILABLE_RESOLVER");return(await n(this,e)).map(s=>new DefaultMultiaddr(s))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){const r=(e??this).protos();return!(r.length!==2||r[0].code!==4&&r[0].code!==41||r[1].code!==6&&r[1].code!==273)}[(_DefaultMultiaddr_string=new WeakMap,_DefaultMultiaddr_tuples=new WeakMap,_DefaultMultiaddr_stringTuples=new WeakMap,_a=symbol$2,inspect$2)](){return`Multiaddr(${bytesToString$1(this.bytes)})`}}function multiaddr$1(t){return new DefaultMultiaddr(t)}function commonjsRequire(t){throw new Error('Could not dynamically require "'+t+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}function isElectron$1(){return!!(typeof window<"u"&&typeof window.process=="object"&&window.process.type==="renderer"||typeof process<"u"&&typeof process.versions=="object"&&process.versions.electron||typeof navigator=="object"&&typeof navigator.userAgent=="string"&&navigator.userAgent.indexOf("Electron")>=0)}var isElectron_1=isElectron$1;const isElectron=isElectron_1,IS_ENV_WITH_DOM=typeof window=="object"&&typeof document=="object"&&document.nodeType===9,IS_ELECTRON=isElectron(),IS_BROWSER=IS_ENV_WITH_DOM&&!IS_ELECTRON;typeof commonjsRequire=="function"&&typeof process<"u"&&typeof process.release<"u"&&process.release.name;const IS_WEBWORKER=typeof importScripts=="function"&&typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope;var env={isBrowser:IS_BROWSER,isWebWorker:IS_WEBWORKER};let durationRE=/(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;parse.year=parse.yr=parse.y=6e4*60*24*365.25;parse.month=parse.b=6e4*60*24*(365.25/12);parse.week=parse.wk=parse.w=6e4*60*24*7;parse.day=parse.d=6e4*60*24;parse.hour=parse.hr=parse.h=6e4*60;parse.minute=parse.min=parse.m=6e4;parse.second=parse.sec=parse.s=1e3;parse.millisecond=parse.millisec=parse.ms=1;parse.s=parse.s=parse.us=parse.microsecond=1/1e3;parse.nanosecond=parse.ns=1/1e6;function parse(t="",e="ms"){var r=null,n;return t=(t+"").replace(/(\d)[,_](\d)/g,"$1$2"),t.replace(durationRE,function(o,s,a){if(a)a=a.toLowerCase();else if(n){for(var i in parse)if(parse[i]<n){a=i;break}}else a=e;Object.prototype.hasOwnProperty.call(parse,a)?a=parse[a]:Object.prototype.hasOwnProperty.call(parse,a.replace(/s$/,""))?a=parse[a.replace(/s$/,"")]:a=null,a&&(r=(r||0)+Math.abs(parseFloat(s,10))*a,n=a)}),r&&r/(parse[e]||1)*(t[0]==="-"?-1:1)}var browser$1={exports:{}},ms,hasRequiredMs;function requireMs(){if(hasRequiredMs)return ms;hasRequiredMs=1;var t=1e3,e=t*60,r=e*60,n=r*24,o=n*7,s=n*365.25;ms=function(l,f){f=f||{};var p=typeof l;if(p==="string"&&l.length>0)return a(l);if(p==="number"&&isFinite(l))return f.long?c(l):i(l);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(l))};function a(l){if(l=String(l),!(l.length>100)){var f=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(l);if(f){var p=parseFloat(f[1]),v=(f[2]||"ms").toLowerCase();switch(v){case"years":case"year":case"yrs":case"yr":case"y":return p*s;case"weeks":case"week":case"w":return p*o;case"days":case"day":case"d":return p*n;case"hours":case"hour":case"hrs":case"hr":case"h":return p*r;case"minutes":case"minute":case"mins":case"min":case"m":return p*e;case"seconds":case"second":case"secs":case"sec":case"s":return p*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return p;default:return}}}}function i(l){var f=Math.abs(l);return f>=n?Math.round(l/n)+"d":f>=r?Math.round(l/r)+"h":f>=e?Math.round(l/e)+"m":f>=t?Math.round(l/t)+"s":l+"ms"}function c(l){var f=Math.abs(l);return f>=n?d(l,f,n,"day"):f>=r?d(l,f,r,"hour"):f>=e?d(l,f,e,"minute"):f>=t?d(l,f,t,"second"):l+" ms"}function d(l,f,p,v){var u=f>=p*1.5;return Math.round(l/p)+" "+v+(u?"s":"")}return ms}function setup(t){r.debug=r,r.default=r,r.coerce=c,r.disable=a,r.enable=o,r.enabled=i,r.humanize=requireMs(),r.destroy=d,Object.keys(t).forEach(l=>{r[l]=t[l]}),r.names=[],r.skips=[],r.formatters={};function e(l){let f=0;for(let p=0;p<l.length;p++)f=(f<<5)-f+l.charCodeAt(p),f|=0;return r.colors[Math.abs(f)%r.colors.length]}r.selectColor=e;function r(l){let f,p=null,v,u;function h(...S){if(!h.enabled)return;const y=h,m=Number(new Date),$=m-(f||m);y.diff=$,y.prev=f,y.curr=m,f=m,S[0]=r.coerce(S[0]),typeof S[0]!="string"&&S.unshift("%O");let b=0;S[0]=S[0].replace(/%([a-zA-Z%])/g,(T,g)=>{if(T==="%%")return"%";b++;const E=r.formatters[g];if(typeof E=="function"){const C=S[b];T=E.call(y,C),S.splice(b,1),b--}return T}),r.formatArgs.call(y,S),(y.log||r.log).apply(y,S)}return h.namespace=l,h.useColors=r.useColors(),h.color=r.selectColor(l),h.extend=n,h.destroy=r.destroy,Object.defineProperty(h,"enabled",{enumerable:!0,configurable:!1,get:()=>p!==null?p:(v!==r.namespaces&&(v=r.namespaces,u=r.enabled(l)),u),set:S=>{p=S}}),typeof r.init=="function"&&r.init(h),h}function n(l,f){const p=r(this.namespace+(typeof f>"u"?":":f)+l);return p.log=this.log,p}function o(l){r.save(l),r.namespaces=l,r.names=[],r.skips=[];const f=(typeof l=="string"?l:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for(const p of f)p[0]==="-"?r.skips.push(p.slice(1)):r.names.push(p)}function s(l,f){let p=0,v=0,u=-1,h=0;for(;p<l.length;)if(v<f.length&&(f[v]===l[p]||f[v]==="*"))f[v]==="*"?(u=v,h=p,v++):(p++,v++);else if(u!==-1)v=u+1,h++,p=h;else return!1;for(;v<f.length&&f[v]==="*";)v++;return v===f.length}function a(){const l=[...r.names,...r.skips.map(f=>"-"+f)].join(",");return r.enable(""),l}function i(l){for(const f of r.skips)if(s(l,f))return!1;for(const f of r.names)if(s(l,f))return!0;return!1}function c(l){return l instanceof Error?l.stack||l.message:l}function d(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return r.enable(r.load()),r}var common=setup;(function(t,e){var r={};e.formatArgs=o,e.save=s,e.load=a,e.useColors=n,e.storage=i(),e.destroy=(()=>{let d=!1;return()=>{d||(d=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function n(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let d;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(d=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(d[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function o(d){if(d[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+d[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),!this.useColors)return;const l="color: "+this.color;d.splice(1,0,l,"color: inherit");let f=0,p=0;d[0].replace(/%[a-zA-Z%]/g,v=>{v!=="%%"&&(f++,v==="%c"&&(p=f))}),d.splice(p,0,l)}e.log=console.debug||console.log||(()=>{});function s(d){try{d?e.storage.setItem("debug",d):e.storage.removeItem("debug")}catch{}}function a(){let d;try{d=e.storage.getItem("debug")||e.storage.getItem("DEBUG")}catch{}return!d&&typeof process<"u"&&"env"in process&&(d=r.DEBUG),d}function i(){try{return localStorage}catch{}}t.exports=common(e);const{formatters:c}=t.exports;c.j=function(d){try{return JSON.stringify(d)}catch(l){return"[UnexpectedJSONParseError]: "+l.message}}})(browser$1,browser$1.exports);var browserExports=browser$1.exports;const debug=getDefaultExportFromCjs(browserExports);function base$1(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var s=t.charAt(o),a=s.charCodeAt(0);if(r[a]!==255)throw new TypeError(s+" is ambiguous");r[a]=o}var i=t.length,c=t.charAt(0),d=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var h=0,S=0,y=0,m=u.length;y!==m&&u[y]===0;)y++,h++;for(var $=(m-y)*l+1>>>0,b=new Uint8Array($);y!==m;){for(var w=u[y],T=0,g=$-1;(w!==0||T<S)&&g!==-1;g--,T++)w+=256*b[g]>>>0,b[g]=w%i>>>0,w=w/i>>>0;if(w!==0)throw new Error("Non-zero carry");S=T,y++}for(var E=$-S;E!==$&&b[E]===0;)E++;for(var C=c.repeat(h);E<$;++E)C+=t.charAt(b[E]);return C}function p(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var h=0;if(u[h]!==" "){for(var S=0,y=0;u[h]===c;)S++,h++;for(var m=(u.length-h)*d+1>>>0,$=new Uint8Array(m);u[h];){var b=r[u.charCodeAt(h)];if(b===255)return;for(var w=0,T=m-1;(b!==0||w<y)&&T!==-1;T--,w++)b+=i*$[T]>>>0,$[T]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");y=w,h++}if(u[h]!==" "){for(var g=m-y;g!==m&&$[g]===0;)g++;for(var E=new Uint8Array(S+(m-g)),C=S;g!==m;)E[C++]=$[g++];return E}}}function v(u){var h=p(u);if(h)return h;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:p,decode:v}}var src$2=base$1,_brrp__multiformats_scope_baseX$1=src$2;const coerce$1=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")};let Encoder$1=class{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Decoder$1=class{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$1(this,e)}},ComposedDecoder$1=class{constructor(e){this.decoders=e}or(e){return or$1(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$1=(t,e)=>new ComposedDecoder$1({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});let Codec$1=class{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$1(e,r,n),this.decoder=new Decoder$1(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const from$1=({name:t,prefix:e,encode:r,decode:n})=>new Codec$1(t,e,r,n),baseX$1=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$1(r,e);return from$1({prefix:t,name:e,encode:n,decode:s=>coerce$1(o(s))})},decode$6=(t,e,r,n)=>{const o={};for(let l=0;l<e.length;++l)o[e[l]]=l;let s=t.length;for(;t[s-1]==="=";)--s;const a=new Uint8Array(s*r/8|0);let i=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[t[l]];if(f===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<r|f,i+=r,i>=8&&(i-=8,a[d++]=255&c>>i)}if(i>=r||255&c<<8-i)throw new SyntaxError("Unexpected end of data");return a},encode$3=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let s="",a=0,i=0;for(let c=0;c<t.length;++c)for(i=i<<8|t[c],a+=8;a>r;)a-=r,s+=e[o&i>>a];if(a&&(s+=e[o&i<<r-a]),n)for(;s.length*r&7;)s+="=";return s},rfc4648$1=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$1({prefix:e,name:t,encode(o){return encode$3(o,n,r)},decode(o){return decode$6(o,n,r,t)}}),base58btc$1=baseX$1({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});baseX$1({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});const base32$2=rfc4648$1({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});rfc4648$1({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});rfc4648$1({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});rfc4648$1({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});rfc4648$1({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});rfc4648$1({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});rfc4648$1({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});rfc4648$1({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});rfc4648$1({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const base64$4=rfc4648$1({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6});rfc4648$1({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6});rfc4648$1({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6});rfc4648$1({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});debug.formatters.b=t=>t==null?"undefined":base58btc$1.baseEncode(t);debug.formatters.t=t=>t==null?"undefined":base32$2.baseEncode(t);debug.formatters.m=t=>t==null?"undefined":base64$4.baseEncode(t);debug.formatters.p=t=>t==null?"undefined":t.toString();debug.formatters.c=t=>t==null?"undefined":t.toString();debug.formatters.k=t=>t==null?"undefined":t.toString();debug.formatters.a=t=>t==null?"undefined":t.toString();function createDisabledLogger(t){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=t,e.destroy=()=>!0,e.extend=()=>e,e}function logger(t){let e=createDisabledLogger(`${t}:trace`);return debug.enabled(`${t}:trace`)&&debug.names.map(r=>r.toString()).find(r=>r.includes(":trace"))!=null&&(e=debug(`${t}:trace`)),Object.assign(debug(t),{error:debug(`${t}:error`),trace:e})}var error={};let TimeoutError$2=class extends Error{constructor(e="Request timed out"){super(e),this.name="TimeoutError"}};error.TimeoutError=TimeoutError$2;let AbortError$1=class extends Error{constructor(e="The operation was aborted."){super(e),this.name="AbortError"}};error.AbortError=AbortError$1;let HTTPError$1=class extends Error{constructor(e){super(e.statusText),this.name="HTTPError",this.response=e}};error.HTTPError=HTTPError$1;var src$1={exports:{}},browser={exports:{}},hasRequiredBrowser;function requireBrowser(){return hasRequiredBrowser||(hasRequiredBrowser=1,function(t,e){var r=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof commonjsGlobal<"u")return commonjsGlobal;throw new Error("unable to locate global object")},n=r();t.exports=e=n.fetch,n.fetch&&(e.default=n.fetch.bind(n)),e.Headers=n.Headers,e.Request=n.Request,e.Response=n.Response}(browser,browser.exports)),browser.exports}globalThis.fetch&&globalThis.Headers&&globalThis.Request&&globalThis.Response?src$1.exports={default:globalThis.fetch,Headers:globalThis.Headers,Request:globalThis.Request,Response:globalThis.Response}:src$1.exports={default:requireBrowser().default,Headers:requireBrowser().Headers,Request:requireBrowser().Request,Response:requireBrowser().Response};var srcExports=src$1.exports,fetch_browser$1=srcExports;const{TimeoutError:TimeoutError$1,AbortError}=error,{Response:Response$1,Request:Request$1,Headers:Headers$1,default:fetch$1}=fetch_browser$1,fetchWithProgress=(t,e={})=>{const r=new XMLHttpRequest;r.open(e.method||"GET",t.toString(),!0);const{timeout:n,headers:o}=e;if(n&&n>0&&n<1/0&&(r.timeout=n),e.overrideMimeType!=null&&r.overrideMimeType(e.overrideMimeType),o)for(const[s,a]of new Headers$1(o))r.setRequestHeader(s,a);return e.signal&&(e.signal.onabort=()=>r.abort()),e.onUploadProgress&&(r.upload.onprogress=e.onUploadProgress),r.responseType="arraybuffer",new Promise((s,a)=>{const i=c=>{switch(c.type){case"error":{s(Response$1.error());break}case"load":{s(new ResponseWithURL(r.responseURL,r.response,{status:r.status,statusText:r.statusText,headers:parseHeaders(r.getAllResponseHeaders())}));break}case"timeout":{a(new TimeoutError$1);break}case"abort":{a(new AbortError);break}}};r.onerror=i,r.onload=i,r.ontimeout=i,r.onabort=i,r.send(e.body)})},fetchWithStreaming=fetch$1,fetchWith=(t,e={})=>e.onUploadProgress!=null?fetchWithProgress(t,e):fetchWithStreaming(t,e),parseHeaders=t=>{const e=new Headers$1;for(const r of t.trim().split(/[\r\n]+/)){const n=r.indexOf(": ");n>0&&e.set(r.slice(0,n),r.slice(n+1))}return e};class ResponseWithURL extends Response$1{constructor(e,r,n){super(r,n),Object.defineProperty(this,"url",{value:e})}}var fetch_browser={fetch:fetchWith,Request:Request$1,Headers:Headers$1},isPlainObj=t=>{if(Object.prototype.toString.call(t)!=="[object Object]")return!1;const e=Object.getPrototypeOf(t);return e===null||e===Object.prototype};const isOptionObject=isPlainObj,{hasOwnProperty}=Object.prototype,{propertyIsEnumerable}=Object,defineProperty=(t,e,r)=>Object.defineProperty(t,e,{value:r,writable:!0,enumerable:!0,configurable:!0}),globalThis$1=commonjsGlobal,defaultMergeOptions={concatArrays:!1,ignoreUndefined:!1},getEnumerableOwnPropertyKeys=t=>{const e=[];for(const r in t)hasOwnProperty.call(t,r)&&e.push(r);if(Object.getOwnPropertySymbols){const r=Object.getOwnPropertySymbols(t);for(const n of r)propertyIsEnumerable.call(t,n)&&e.push(n)}return e};function clone(t){return Array.isArray(t)?cloneArray(t):isOptionObject(t)?cloneOptionObject(t):t}function cloneArray(t){const e=t.slice(0,0);return getEnumerableOwnPropertyKeys(t).forEach(r=>{defineProperty(e,r,clone(t[r]))}),e}function cloneOptionObject(t){const e=Object.getPrototypeOf(t)===null?Object.create(null):{};return getEnumerableOwnPropertyKeys(t).forEach(r=>{defineProperty(e,r,clone(t[r]))}),e}const mergeKeys=(t,e,r,n)=>(r.forEach(o=>{typeof e[o]>"u"&&n.ignoreUndefined||(o in t&&t[o]!==Object.getPrototypeOf(t)?defineProperty(t,o,merge$2(t[o],e[o],n)):defineProperty(t,o,clone(e[o])))}),t),concatArrays=(t,e,r)=>{let n=t.slice(0,0),o=0;return[t,e].forEach(s=>{const a=[];for(let i=0;i<s.length;i++)hasOwnProperty.call(s,i)&&(a.push(String(i)),s===t?defineProperty(n,o++,s[i]):defineProperty(n,o++,clone(s[i])));n=mergeKeys(n,s,getEnumerableOwnPropertyKeys(s).filter(i=>!a.includes(i)),r)}),n};function merge$2(t,e,r){return r.concatArrays&&Array.isArray(t)&&Array.isArray(e)?concatArrays(t,e,r):!isOptionObject(e)||!isOptionObject(t)?clone(e):mergeKeys(t,e,getEnumerableOwnPropertyKeys(e),r)}var mergeOptions=function(...t){const e=merge$2(clone(defaultMergeOptions),this!==globalThis$1&&this||{},defaultMergeOptions);let r={_:{}};for(const n of t)if(n!==void 0){if(!isOptionObject(n))throw new TypeError("`"+n+"` is not an Option Object");r=merge$2(r,{_:n},e)}return r._};const mergeOpts=getDefaultExportFromCjs(mergeOptions),isReactNative=typeof navigator<"u"&&navigator.product==="ReactNative";function getDefaultBase(){return isReactNative?"http://localhost":self.location?self.location.protocol+"//"+self.location.host:""}const URL$2=self.URL,defaultBase$1=getDefaultBase();let URLWithLegacySupport$2=class{constructor(e="",r=defaultBase$1){this.super=new URL$2(e,r),this.path=this.pathname+this.search,this.auth=this.username&&this.password?this.username+":"+this.password:null,this.query=this.search&&this.search.startsWith("?")?this.search.slice(1):null}get hash(){return this.super.hash}get host(){return this.super.host}get hostname(){return this.super.hostname}get href(){return this.super.href}get origin(){return this.super.origin}get password(){return this.super.password}get pathname(){return this.super.pathname}get port(){return this.super.port}get protocol(){return this.super.protocol}get search(){return this.super.search}get searchParams(){return this.super.searchParams}get username(){return this.super.username}set hash(e){this.super.hash=e}set host(e){this.super.host=e}set hostname(e){this.super.hostname=e}set href(e){this.super.href=e}set password(e){this.super.password=e}set pathname(e){this.super.pathname=e}set port(e){this.super.port=e}set protocol(e){this.super.protocol=e}set search(e){this.super.search=e}set username(e){this.super.username=e}static createObjectURL(e){return URL$2.createObjectURL(e)}static revokeObjectURL(e){URL$2.revokeObjectURL(e)}toJSON(){return this.super.toJSON()}toString(){return this.super.toString()}format(){return this.toString()}};function format$3(t){if(typeof t=="string")return new URL$2(t).toString();if(!(t instanceof URL$2)){const e=t.username&&t.password?`${t.username}:${t.password}@`:"",r=t.auth?t.auth+"@":"",n=t.port?":"+t.port:"",o=t.protocol?t.protocol+"//":"",s=t.host||"",a=t.hostname||"",i=t.search||(t.query?"?"+t.query:""),c=t.hash||"",d=t.pathname||"",l=t.path||d+i;return`${o}${e||r}${s||a+n}${l}${c}`}}var urlBrowser={URLWithLegacySupport:URLWithLegacySupport$2,URLSearchParams:self.URLSearchParams,defaultBase:defaultBase$1,format:format$3};const{URLWithLegacySupport:URLWithLegacySupport$1,format:format$2}=urlBrowser,{URLWithLegacySupport,format:format$1,URLSearchParams:URLSearchParams$2,defaultBase}=urlBrowser;var isoUrl={URL:URLWithLegacySupport,URLSearchParams:URLSearchParams$2},anySignal$2={exports:{}};function anySignal$1(t){const e=new globalThis.AbortController;function r(){e.abort();for(const n of t)!n||!n.removeEventListener||n.removeEventListener("abort",r)}for(const n of t)if(!(!n||!n.addEventListener)){if(n.aborted){r();break}n.addEventListener("abort",r)}return e.signal}anySignal$2.exports=anySignal$1;var anySignal_2=anySignal$2.exports.anySignal=anySignal$1,anySignalExports=anySignal$2.exports;async function*browserReadableStreamToIt$1(t,e={}){const r=t.getReader();try{for(;;){const n=await r.read();if(n.done)return;yield n.value}}finally{e.preventCancel!==!0&&r.cancel(),r.releaseLock()}}var browserReadablestreamToIt=browserReadableStreamToIt$1;const all$2=async t=>{const e=[];for await(const r of t)e.push(r);return e};var itAll=all$2;const{fetch,Request,Headers}=fetch_browser,{TimeoutError,HTTPError}=error,merge$1=mergeOptions.bind({ignoreUndefined:!0}),{URL:URL$1,URLSearchParams:URLSearchParams$1}=isoUrl,anySignal=anySignalExports,browserReableStreamToIt=browserReadablestreamToIt,{isBrowser,isWebWorker}=env,all$1=itAll,timeout=(t,e,r)=>{if(e===void 0)return t;const n=Date.now(),o=()=>Date.now()-n>=e;return new Promise((s,a)=>{const i=setTimeout(()=>{o()&&(a(new TimeoutError),r.abort())},e),c=d=>f=>{if(clearTimeout(i),o()){a(new TimeoutError);return}d(f)};t.then(c(s),c(a))})},defaults={throwHttpErrors:!0,credentials:"same-origin"};class HTTP{constructor(e={}){this.opts=merge$1(defaults,e)}async fetch(e,r={}){const n=merge$1(this.opts,r),o=new Headers(n.headers);if(typeof e!="string"&&!(e instanceof URL$1||e instanceof Request))throw new TypeError("`resource` must be a string, URL, or Request");const s=new URL$1(e.toString(),n.base),{searchParams:a,transformSearchParams:i,json:c}=n;a&&(typeof i=="function"?s.search=i(new URLSearchParams$1(n.searchParams)):s.search=new URLSearchParams$1(n.searchParams)),c&&(n.body=JSON.stringify(n.json),o.set("content-type","application/json"));const d=new AbortController,l=anySignal([d.signal,n.signal]);globalThis.ReadableStream!=null&&n.body instanceof globalThis.ReadableStream&&(isBrowser||isWebWorker)&&(n.body=new Blob(await all$1(browserReableStreamToIt(n.body))));const f=await timeout(fetch(s.toString(),{...n,signal:l,timeout:void 0,headers:o,duplex:"half"}),n.timeout,d);if(!f.ok&&n.throwHttpErrors)throw n.handleError&&await n.handleError(f),new HTTPError(f);return f.iterator=async function*(){yield*fromStream(f.body)},f.ndjson=async function*(){for await(const p of ndjson(f.iterator()))r.transform?yield r.transform(p):yield p},f}post(e,r={}){return this.fetch(e,{...r,method:"POST"})}get(e,r={}){return this.fetch(e,{...r,method:"GET"})}put(e,r={}){return this.fetch(e,{...r,method:"PUT"})}delete(e,r={}){return this.fetch(e,{...r,method:"DELETE"})}options(e,r={}){return this.fetch(e,{...r,method:"OPTIONS"})}}const ndjson=async function*(t){const e=new TextDecoder;let r="";for await(const n of t){r+=e.decode(n,{stream:!0});const o=r.split(/\r?\n/);for(let s=0;s<o.length-1;s++){const a=o[s].trim();a.length>0&&(yield JSON.parse(a))}r=o[o.length-1]}r+=e.decode(),r=r.trim(),r.length!==0&&(yield JSON.parse(r))},fromStream=t=>{if(isAsyncIterable(t))return t;if(isNodeReadableStream(t)){const e=t[Symbol.asyncIterator]();return{[Symbol.asyncIterator](){return{next:e.next.bind(e),return(r){return t.destroy(),typeof e.return=="function"?e.return():Promise.resolve({done:!0,value:r})}}}}}if(isWebReadableStream(t)){const e=t.getReader();return async function*(){try{for(;;){const{done:r,value:n}=await e.read();if(r)return;n&&(yield n)}}finally{e.releaseLock()}}()}throw new TypeError("Body can't be converted to AsyncIterable")},isAsyncIterable=t=>typeof t=="object"&&t!==null&&typeof t[Symbol.asyncIterator]=="function",isWebReadableStream=t=>t&&typeof t.getReader=="function",isNodeReadableStream=t=>Object.prototype.hasOwnProperty.call(t,"readable")&&Object.prototype.hasOwnProperty.call(t,"writable");HTTP.HTTPError=HTTPError;HTTP.TimeoutError=TimeoutError;HTTP.streamToAsyncIterator=fromStream;HTTP.post=(t,e)=>new HTTP(e).post(t,e);HTTP.get=(t,e)=>new HTTP(e).get(t,e);HTTP.put=(t,e)=>new HTTP(e).put(t,e);HTTP.delete=(t,e)=>new HTTP(e).delete(t,e);HTTP.options=(t,e)=>new HTTP(e).options(t,e);var http=HTTP;const HTTP$1=getDefaultExportFromCjs(http);function equals$2(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}function coerce(t){if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")}function fromString$1(t){return new TextEncoder().encode(t)}function toString$1(t){return new TextDecoder().decode(t)}function base(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var s=t.charAt(o),a=s.charCodeAt(0);if(r[a]!==255)throw new TypeError(s+" is ambiguous");r[a]=o}var i=t.length,c=t.charAt(0),d=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var h=0,S=0,y=0,m=u.length;y!==m&&u[y]===0;)y++,h++;for(var $=(m-y)*l+1>>>0,b=new Uint8Array($);y!==m;){for(var w=u[y],T=0,g=$-1;(w!==0||T<S)&&g!==-1;g--,T++)w+=256*b[g]>>>0,b[g]=w%i>>>0,w=w/i>>>0;if(w!==0)throw new Error("Non-zero carry");S=T,y++}for(var E=$-S;E!==$&&b[E]===0;)E++;for(var C=c.repeat(h);E<$;++E)C+=t.charAt(b[E]);return C}function p(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var h=0;if(u[h]!==" "){for(var S=0,y=0;u[h]===c;)S++,h++;for(var m=(u.length-h)*d+1>>>0,$=new Uint8Array(m);u[h];){var b=r[u.charCodeAt(h)];if(b===255)return;for(var w=0,T=m-1;(b!==0||w<y)&&T!==-1;T--,w++)b+=i*$[T]>>>0,$[T]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");y=w,h++}if(u[h]!==" "){for(var g=m-y;g!==m&&$[g]===0;)g++;for(var E=new Uint8Array(S+(m-g)),C=S;g!==m;)E[C++]=$[g++];return E}}}function v(u){var h=p(u);if(h)return h;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:p,decode:v}}var src=base,_brrp__multiformats_scope_baseX=src;class Encoder{constructor(e,r,n){P(this,"name");P(this,"prefix");P(this,"baseEncode");this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Decoder{constructor(e,r,n){P(this,"name");P(this,"prefix");P(this,"baseDecode");P(this,"prefixCodePoint");this.name=e,this.prefix=r;const o=r.codePointAt(0);if(o===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=o,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or(this,e)}}class ComposedDecoder{constructor(e){P(this,"decoders");this.decoders=e}or(e){return or(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function or(t,e){return new ComposedDecoder({...t.decoders??{[t.prefix]:t},...e.decoders??{[e.prefix]:e}})}class Codec{constructor(e,r,n,o){P(this,"name");P(this,"prefix");P(this,"baseEncode");P(this,"baseDecode");P(this,"encoder");P(this,"decoder");this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder(e,r,n),this.decoder=new Decoder(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function from({name:t,prefix:e,encode:r,decode:n}){return new Codec(t,e,r,n)}function baseX({name:t,prefix:e,alphabet:r}){const{encode:n,decode:o}=_brrp__multiformats_scope_baseX(r,t);return from({prefix:e,name:t,encode:n,decode:s=>coerce(o(s))})}function decode$5(t,e,r,n){let o=t.length;for(;t[o-1]==="=";)--o;const s=new Uint8Array(o*r/8|0);let a=0,i=0,c=0;for(let d=0;d<o;++d){const l=e[t[d]];if(l===void 0)throw new SyntaxError(`Non-${n} character`);i=i<<r|l,a+=r,a>=8&&(a-=8,s[c++]=255&i>>a)}if(a>=r||255&i<<8-a)throw new SyntaxError("Unexpected end of data");return s}function encode$2(t,e,r){const n=e[e.length-1]==="=",o=(1<<r)-1;let s="",a=0,i=0;for(let c=0;c<t.length;++c)for(i=i<<8|t[c],a+=8;a>r;)a-=r,s+=e[o&i>>a];if(a!==0&&(s+=e[o&i<<r-a]),n)for(;s.length*r&7;)s+="=";return s}function createAlphabetIdx(t){const e={};for(let r=0;r<t.length;++r)e[t[r]]=r;return e}function rfc4648({name:t,prefix:e,bitsPerChar:r,alphabet:n}){const o=createAlphabetIdx(n);return from({prefix:e,name:t,encode(s){return encode$2(s,n,r)},decode(s){return decode$5(s,o,r,t)}})}const base10=baseX({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$1=Object.freeze(Object.defineProperty({__proto__:null,base10},Symbol.toStringTag,{value:"Module"})),base16=rfc4648({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper=rfc4648({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$1=Object.freeze(Object.defineProperty({__proto__:null,base16,base16upper},Symbol.toStringTag,{value:"Module"})),base2=rfc4648({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$1=Object.freeze(Object.defineProperty({__proto__:null,base2},Symbol.toStringTag,{value:"Module"})),alphabet=Array.from(""),alphabetBytesToChars=alphabet.reduce((t,e,r)=>(t[r]=e,t),[]),alphabetCharsToBytes=alphabet.reduce((t,e,r)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return t[n]=r,t},[]);function encode$1(t){return t.reduce((e,r)=>(e+=alphabetBytesToChars[r],e),"")}function decode$4(t){const e=[];for(const r of t){const n=r.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${r}`);const o=alphabetCharsToBytes[n];if(o==null)throw new Error(`Non-base256emoji character: ${r}`);e.push(o)}return new Uint8Array(e)}const base256emoji=from({prefix:"",name:"base256emoji",encode:encode$1,decode:decode$4}),base256emoji$1=Object.freeze(Object.defineProperty({__proto__:null,base256emoji},Symbol.toStringTag,{value:"Module"})),base32=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper=rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad=rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper=rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex=rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper=rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad=rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper=rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z=rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$1=Object.freeze(Object.defineProperty({__proto__:null,base32,base32hex,base32hexpad,base32hexpadupper,base32hexupper,base32pad,base32padupper,base32upper,base32z},Symbol.toStringTag,{value:"Module"})),base36=baseX({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper=baseX({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$1=Object.freeze(Object.defineProperty({__proto__:null,base36,base36upper},Symbol.toStringTag,{value:"Module"})),base58btc=baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr=baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58=Object.freeze(Object.defineProperty({__proto__:null,base58btc,base58flickr},Symbol.toStringTag,{value:"Module"})),base64$2=rfc4648({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad=rfc4648({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url=rfc4648({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad=rfc4648({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$3=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$2,base64pad,base64url,base64urlpad},Symbol.toStringTag,{value:"Module"})),base8=rfc4648({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$1=Object.freeze(Object.defineProperty({__proto__:null,base8},Symbol.toStringTag,{value:"Module"})),identity=from({prefix:"\0",name:"identity",encode:t=>toString$1(t),decode:t=>fromString$1(t)}),identityBase=Object.freeze(Object.defineProperty({__proto__:null,identity},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;var encode_1=encode,MSB$1=128,MSBALL=-128,INT=Math.pow(2,31);function encode(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT;)e[r++]=t&255|MSB$1,t/=128;for(;t&MSBALL;)e[r++]=t&255|MSB$1,t>>>=7;return e[r]=t|0,encode.bytes=r-n+1,e}var decode$3=read,MSB$1$1=128,REST$1=127;function read(t,n){var r=0,n=n||0,o=0,s=n,a,i=t.length;do{if(s>=i)throw read.bytes=0,new RangeError("Could not decode varint");a=t[s++],r+=o<28?(a&REST$1)<<o:(a&REST$1)*Math.pow(2,o),o+=7}while(a>=MSB$1$1);return read.bytes=s-n,r}var N1$1=Math.pow(2,7),N2$1=Math.pow(2,14),N3$1=Math.pow(2,21),N4$1=Math.pow(2,28),N5$1=Math.pow(2,35),N6$1=Math.pow(2,42),N7$1=Math.pow(2,49),N8=Math.pow(2,56),N9=Math.pow(2,63),length=function(t){return t<N1$1?1:t<N2$1?2:t<N3$1?3:t<N4$1?4:t<N5$1?5:t<N6$1?6:t<N7$1?7:t<N8?8:t<N9?9:10},varint={encode:encode_1,decode:decode$3,encodingLength:length},_brrp_varint=varint;function decode$2(t,e=0){return[_brrp_varint.decode(t,e),_brrp_varint.decode.bytes]}function encodeTo(t,e,r=0){return _brrp_varint.encode(t,e,r),e}function encodingLength$1(t){return _brrp_varint.encodingLength(t)}function create$3(t,e){const r=e.byteLength,n=encodingLength$1(t),o=n+encodingLength$1(r),s=new Uint8Array(o+r);return encodeTo(t,s,0),encodeTo(r,s,n),s.set(e,o),new Digest(t,r,e,s)}function decode$1(t){const e=coerce(t),[r,n]=decode$2(e),[o,s]=decode$2(e.subarray(n)),a=e.subarray(n+s);if(a.byteLength!==o)throw new Error("Incorrect length");return new Digest(r,o,a,e)}function equals$1(t,e){if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&equals$2(t.bytes,r.bytes)}}class Digest{constructor(e,r,n,o){P(this,"code");P(this,"size");P(this,"digest");P(this,"bytes");this.code=e,this.size=r,this.digest=n,this.bytes=o}}function format(t,e){const{bytes:r,version:n}=t;switch(n){case 0:return toStringV0(r,baseCache(t),e??base58btc.encoder);default:return toStringV1(r,baseCache(t),e??base32.encoder)}}const cache=new WeakMap;function baseCache(t){const e=cache.get(t);if(e==null){const r=new Map;return cache.set(t,r),r}return e}var F;class CID{constructor(e,r,n,o){P(this,"code");P(this,"version");P(this,"multihash");P(this,"bytes");P(this,"/");P(this,F,"CID");this.code=r,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID.createV0(r)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create$3(e,r);return CID.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return CID.equals(this,e)}static equals(e,r){const n=r;return n!=null&&e.code===n.code&&e.version===n.version&&equals$1(e.multihash,n.multihash)}toString(e){return format(this,e)}toJSON(){return{"/":format(this)}}link(){return this}[(F=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const r=e;if(r instanceof CID)return r;if(r["/"]!=null&&r["/"]===r.bytes||r.asCID===r){const{version:n,code:o,multihash:s,bytes:a}=r;return new CID(n,o,s,a??encodeCID$1(n,o,s.bytes))}else if(r[cidSymbol]===!0){const{version:n,multihash:o,code:s}=r,a=decode$1(o);return CID.create(n,s,a)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(r!==DAG_PB_CODE)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);return new CID(e,r,n,n.bytes)}case 1:{const o=encodeCID$1(e,r,n.bytes);return new CID(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return CID.create(0,DAG_PB_CODE,e)}static createV1(e,r){return CID.create(1,e,r)}static decode(e){const[r,n]=CID.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=CID.inspectBytes(e),n=r.size-r.multihashSize,o=coerce(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");const s=o.subarray(r.multihashSize-r.digestSize),a=new Digest(r.multihashCode,r.digestSize,s,o);return[r.version===0?CID.createV0(a):CID.createV1(r.codec,a),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[f,p]=decode$2(e.subarray(r));return r+=p,f};let o=n(),s=DAG_PB_CODE;if(o===18?(o=0,r=0):s=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const a=r,i=n(),c=n(),d=r+c,l=d-a;return{version:o,codec:s,multihashCode:i,digestSize:c,multihashSize:l,size:d}}static parse(e,r){const[n,o]=parseCIDtoBytes(e,r),s=CID.decode(o);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return baseCache(s).set(n,e),s}}function parseCIDtoBytes(t,e){switch(t[0]){case"Q":{const r=e??base58btc;return[base58btc.prefix,r.decode(`${base58btc.prefix}${t}`)]}case base58btc.prefix:{const r=e??base58btc;return[base58btc.prefix,r.decode(t)]}case base32.prefix:{const r=e??base32;return[base32.prefix,r.decode(t)]}case base36.prefix:{const r=e??base36;return[base36.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}}function toStringV0(t,e,r){const{prefix:n}=r;if(n!==base58btc.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=e.get(n);if(o==null){const s=r.encode(t).slice(1);return e.set(n,s),s}else return o}function toStringV1(t,e,r){const{prefix:n}=r,o=e.get(n);if(o==null){const s=r.encode(t);return e.set(n,s),s}else return o}const DAG_PB_CODE=112,SHA_256_CODE=18;function encodeCID$1(t,e,r){const n=encodingLength$1(t),o=n+encodingLength$1(e),s=new Uint8Array(o+r.byteLength);return encodeTo(t,s,0),encodeTo(e,s,n),s.set(r,o),s}const cidSymbol=Symbol.for("@ipld/js-cid/CID"),bases={...identityBase,...base2$1,...base8$1,...base10$1,...base16$1,...base32$1,...base36$1,...base58,...base64$3,...base256emoji$1};function allocUnsafe(t=0){return new Uint8Array(t)}function createCodec(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}const string=createCodec("utf8","u",t=>"u"+new TextDecoder("utf8").decode(t),t=>new TextEncoder().encode(t.substring(1))),ascii=createCodec("ascii","a",t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},t=>{t=t.substring(1);const e=allocUnsafe(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}),BASES={utf8:string,"utf-8":string,hex:bases.base16,latin1:ascii,ascii,binary:ascii,...bases};function toString(t,e="utf8"){const r=BASES[e];if(r==null)throw new Error(`Unsupported encoding "${e}"`);return r.encoder.encode(t).substring(1)}class InvalidMultiaddrError extends Error{constructor(){super(...arguments);P(this,"name","InvalidMultiaddrError")}}P(InvalidMultiaddrError,"name","InvalidMultiaddrError");class ValidationError extends Error{constructor(){super(...arguments);P(this,"name","ValidationError")}}P(ValidationError,"name","ValidationError");class InvalidParametersError extends Error{constructor(){super(...arguments);P(this,"name","InvalidParametersError")}}P(InvalidParametersError,"name","InvalidParametersError");class UnknownProtocolError extends Error{constructor(){super(...arguments);P(this,"name","UnknownProtocolError")}}P(UnknownProtocolError,"name","UnknownProtocolError");function equals(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}function fromString(t,e="utf8"){const r=BASES[e];if(r==null)throw new Error(`Unsupported encoding "${e}"`);return r.decoder.decode(`${r.prefix}${t}`)}const N1=Math.pow(2,7),N2=Math.pow(2,14),N3=Math.pow(2,21),N4=Math.pow(2,28),N5=Math.pow(2,35),N6=Math.pow(2,42),N7=Math.pow(2,49),MSB=128,REST=127;function encodingLength(t){if(t<N1)return 1;if(t<N2)return 2;if(t<N3)return 3;if(t<N4)return 4;if(t<N5)return 5;if(t<N6)return 6;if(t<N7)return 7;if(Number.MAX_SAFE_INTEGER!=null&&t>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function encodeUint8Array(t,e,r=0){switch(encodingLength(t)){case 8:e[r++]=t&255|MSB,t/=128;case 7:e[r++]=t&255|MSB,t/=128;case 6:e[r++]=t&255|MSB,t/=128;case 5:e[r++]=t&255|MSB,t/=128;case 4:e[r++]=t&255|MSB,t>>>=7;case 3:e[r++]=t&255|MSB,t>>>=7;case 2:e[r++]=t&255|MSB,t>>>=7;case 1:{e[r++]=t&255,t>>>=7;break}default:throw new Error("unreachable")}return e}function decodeUint8Array(t,e){let r=t[e],n=0;if(n+=r&REST,r<MSB||(r=t[e+1],n+=(r&REST)<<7,r<MSB)||(r=t[e+2],n+=(r&REST)<<14,r<MSB)||(r=t[e+3],n+=(r&REST)<<21,r<MSB)||(r=t[e+4],n+=(r&REST)*N4,r<MSB)||(r=t[e+5],n+=(r&REST)*N5,r<MSB)||(r=t[e+6],n+=(r&REST)*N6,r<MSB)||(r=t[e+7],n+=(r&REST)*N7,r<MSB))return n;throw new RangeError("Could not decode varint")}function decodeUint8ArrayList(t,e){let r=t.get(e),n=0;if(n+=r&REST,r<MSB||(r=t.get(e+1),n+=(r&REST)<<7,r<MSB)||(r=t.get(e+2),n+=(r&REST)<<14,r<MSB)||(r=t.get(e+3),n+=(r&REST)<<21,r<MSB)||(r=t.get(e+4),n+=(r&REST)*N4,r<MSB)||(r=t.get(e+5),n+=(r&REST)*N5,r<MSB)||(r=t.get(e+6),n+=(r&REST)*N6,r<MSB)||(r=t.get(e+7),n+=(r&REST)*N7,r<MSB))return n;throw new RangeError("Could not decode varint")}function decode(t,e=0){return t instanceof Uint8Array?decodeUint8Array(t,e):decodeUint8ArrayList(t,e)}function asUint8Array(t){return t}function concat(t,e){e==null&&(e=t.reduce((o,s)=>o+s.length,0));const r=allocUnsafe(e);let n=0;for(const o of t)r.set(o,n),n+=o.length;return r}const CODE_IP4=4,CODE_TCP=6,CODE_UDP=273,CODE_DCCP=33,CODE_IP6=41,CODE_IP6ZONE=42,CODE_IPCIDR=43,CODE_DNS=53,CODE_DNS4=54,CODE_DNS6=55,CODE_DNSADDR=56,CODE_SCTP=132,CODE_UDT=301,CODE_UTP=302,CODE_UNIX=400,CODE_P2P=421,CODE_ONION=444,CODE_ONION3=445,CODE_GARLIC64=446,CODE_GARLIC32=447,CODE_TLS=448,CODE_SNI=449,CODE_NOISE=454,CODE_QUIC=460,CODE_QUIC_V1=461,CODE_WEBTRANSPORT=465,CODE_CERTHASH=466,CODE_HTTP=480,CODE_HTTP_PATH=481,CODE_HTTPS=443,CODE_WS=477,CODE_WSS=478,CODE_P2P_WEBSOCKET_STAR=479,CODE_P2P_STARDUST=277,CODE_P2P_WEBRTC_STAR=275,CODE_P2P_WEBRTC_DIRECT=276,CODE_WEBRTC_DIRECT=280,CODE_WEBRTC=281,CODE_P2P_CIRCUIT=290,CODE_MEMORY=777;function bytesToString(t){return e=>toString(e,t)}function stringToBytes(t){return e=>fromString(e,t)}function bytes2port(t){return new DataView(t.buffer).getUint16(t.byteOffset).toString()}function port2bytes(t){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof t=="string"?parseInt(t):t),new Uint8Array(e)}function onion2bytes(t){const e=t.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const r=fromString(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const o=port2bytes(n);return concat([r,o],r.length+o.length)}function onion32bytes(t){const e=t.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const r=base32.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const o=port2bytes(n);return concat([r,o],r.length+o.length)}function bytes2onion(t){const e=t.subarray(0,t.length-2),r=t.subarray(t.length-2),n=toString(e,"base32"),o=bytes2port(r);return`${n}:${o}`}const ip4ToBytes=function(t){t=t.toString().trim();const e=new Uint8Array(4);return t.split(/\./g).forEach((r,n)=>{const o=parseInt(r,10);if(isNaN(o)||o<0||o>255)throw new InvalidMultiaddrError("Invalid byte value in IP address");e[n]=o}),e},ip6ToBytes=function(t){let e=0;t=t.toString().trim();const r=t.split(":",8);let n;for(n=0;n<r.length;n++){const s=isIPv4(r[n]);let a;s&&(a=ip4ToBytes(r[n]),r[n]=toString(a.subarray(0,2),"base16")),a!=null&&++n<8&&r.splice(n,0,toString(a.subarray(2,4),"base16"))}if(r[0]==="")for(;r.length<8;)r.unshift("0");else if(r[r.length-1]==="")for(;r.length<8;)r.push("0");else if(r.length<8){for(n=0;n<r.length&&r[n]!=="";n++);const s=[n,1];for(n=9-r.length;n>0;n--)s.push("0");r.splice.apply(r,s)}const o=new Uint8Array(e+16);for(n=0;n<r.length;n++){r[n]===""&&(r[n]="0");const s=parseInt(r[n],16);if(isNaN(s)||s<0||s>65535)throw new InvalidMultiaddrError("Invalid byte value in IP address");o[e++]=s>>8&255,o[e++]=s&255}return o},ip4ToString=function(t){if(t.byteLength!==4)throw new InvalidMultiaddrError("IPv4 address was incorrect length");const e=[];for(let r=0;r<t.byteLength;r++)e.push(t[r]);return e.join(".")},ip6ToString=function(t){if(t.byteLength!==16)throw new InvalidMultiaddrError("IPv6 address was incorrect length");const e=[];for(let n=0;n<t.byteLength;n+=2){const o=t[n],s=t[n+1],a=`${o.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(a)}const r=e.join(":");try{const n=new URL(`http://[${r}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new InvalidMultiaddrError(`Invalid IPv6 address "${r}"`)}};function ip6StringToValue(t){try{const e=new URL(`http://[${t}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new InvalidMultiaddrError(`Invalid IPv6 address "${t}"`)}}const decoders=Object.values(bases).map(t=>t.decoder),anybaseDecoder=function(){let t=decoders[0].or(decoders[1]);return decoders.slice(2).forEach(e=>t=t.or(e)),t}();function mb2bytes(t){return anybaseDecoder.decode(t)}function bytes2mb(t){return e=>t.encoder.encode(e)}function integer(t){if(parseInt(t).toString()!==t)throw new ValidationError("Value must be an integer")}function positive(t){if(t<0)throw new ValidationError("Value must be a positive integer, or zero")}function maxValue(t){return e=>{if(e>t)throw new ValidationError(`Value must be smaller than or equal to ${t}`)}}function validate$1(...t){return e=>{for(const r of t)r(e)}}const validatePort=validate$1(integer,positive,maxValue(65535)),V=-1;class Registry{constructor(){P(this,"protocolsByCode",new Map);P(this,"protocolsByName",new Map)}getProtocol(e){let r;if(typeof e=="string"?r=this.protocolsByName.get(e):r=this.protocolsByCode.get(e),r==null)throw new UnknownProtocolError(`Protocol ${e} was unknown`);return r}addProtocol(e){var r;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(r=e.aliases)==null||r.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const r=this.protocolsByCode.get(e);r!=null&&(this.protocolsByCode.delete(r.code),this.protocolsByName.delete(r.name),(n=r.aliases)==null||n.forEach(o=>{this.protocolsByName.delete(o)}))}}const registry=new Registry,codecs=[{code:CODE_IP4,name:"ip4",size:32,valueToBytes:ip4ToBytes,bytesToValue:ip4ToString,validate:t=>{if(!isIPv4(t))throw new ValidationError(`Invalid IPv4 address "${t}"`)}},{code:CODE_TCP,name:"tcp",size:16,valueToBytes:port2bytes,bytesToValue:bytes2port,validate:validatePort},{code:CODE_UDP,name:"udp",size:16,valueToBytes:port2bytes,bytesToValue:bytes2port,validate:validatePort},{code:CODE_DCCP,name:"dccp",size:16,valueToBytes:port2bytes,bytesToValue:bytes2port,validate:validatePort},{code:CODE_IP6,name:"ip6",size:128,valueToBytes:ip6ToBytes,bytesToValue:ip6ToString,stringToValue:ip6StringToValue,validate:t=>{if(!isIPv6(t))throw new ValidationError(`Invalid IPv6 address "${t}"`)}},{code:CODE_IP6ZONE,name:"ip6zone",size:V},{code:CODE_IPCIDR,name:"ipcidr",size:8,bytesToValue:bytesToString("base10"),valueToBytes:stringToBytes("base10")},{code:CODE_DNS,name:"dns",size:V,resolvable:!0},{code:CODE_DNS4,name:"dns4",size:V,resolvable:!0},{code:CODE_DNS6,name:"dns6",size:V,resolvable:!0},{code:CODE_DNSADDR,name:"dnsaddr",size:V,resolvable:!0},{code:CODE_SCTP,name:"sctp",size:16,valueToBytes:port2bytes,bytesToValue:bytes2port,validate:validatePort},{code:CODE_UDT,name:"udt"},{code:CODE_UTP,name:"utp"},{code:CODE_UNIX,name:"unix",size:V,path:!0,stringToValue:t=>decodeURIComponent(t),valueToString:t=>encodeURIComponent(t)},{code:CODE_P2P,name:"p2p",aliases:["ipfs"],size:V,bytesToValue:bytesToString("base58btc"),valueToBytes:t=>t.startsWith("Q")||t.startsWith("1")?stringToBytes("base58btc")(t):CID.parse(t).multihash.bytes},{code:CODE_ONION,name:"onion",size:96,bytesToValue:bytes2onion,valueToBytes:onion2bytes},{code:CODE_ONION3,name:"onion3",size:296,bytesToValue:bytes2onion,valueToBytes:onion32bytes},{code:CODE_GARLIC64,name:"garlic64",size:V},{code:CODE_GARLIC32,name:"garlic32",size:V},{code:CODE_TLS,name:"tls"},{code:CODE_SNI,name:"sni",size:V},{code:CODE_NOISE,name:"noise"},{code:CODE_QUIC,name:"quic"},{code:CODE_QUIC_V1,name:"quic-v1"},{code:CODE_WEBTRANSPORT,name:"webtransport"},{code:CODE_CERTHASH,name:"certhash",size:V,bytesToValue:bytes2mb(base64url),valueToBytes:mb2bytes},{code:CODE_HTTP,name:"http"},{code:CODE_HTTP_PATH,name:"http-path",size:V,stringToValue:t=>`/${decodeURIComponent(t)}`,valueToString:t=>encodeURIComponent(t.substring(1))},{code:CODE_HTTPS,name:"https"},{code:CODE_WS,name:"ws"},{code:CODE_WSS,name:"wss"},{code:CODE_P2P_WEBSOCKET_STAR,name:"p2p-websocket-star"},{code:CODE_P2P_STARDUST,name:"p2p-stardust"},{code:CODE_P2P_WEBRTC_STAR,name:"p2p-webrtc-star"},{code:CODE_P2P_WEBRTC_DIRECT,name:"p2p-webrtc-direct"},{code:CODE_WEBRTC_DIRECT,name:"webrtc-direct"},{code:CODE_WEBRTC,name:"webrtc"},{code:CODE_P2P_CIRCUIT,name:"p2p-circuit"},{code:CODE_MEMORY,name:"memory",size:V}];codecs.forEach(t=>{registry.addProtocol(t)});function bytesToComponents(t){var n;const e=[];let r=0;for(;r<t.length;){const o=decode(t,r),s=registry.getProtocol(o),a=encodingLength(o),i=sizeForAddr(s,t,r+a);let c=0;i>0&&s.size===V&&(c=encodingLength(i));const d=a+c+i,l={code:o,name:s.name,bytes:t.subarray(r,r+d)};if(i>0){const f=r+a+c,p=t.subarray(f,f+i);l.value=((n=s.bytesToValue)==null?void 0:n.call(s,p))??toString(p)}e.push(l),r+=d}return e}function componentsToBytes(t){var n;let e=0;const r=[];for(const o of t){if(o.bytes==null){const s=registry.getProtocol(o.code),a=encodingLength(o.code);let i,c=0,d=0;o.value!=null&&(i=((n=s.valueToBytes)==null?void 0:n.call(s,o.value))??fromString(o.value),c=i.byteLength,s.size===V&&(d=encodingLength(c)));const l=new Uint8Array(a+d+c);let f=0;encodeUint8Array(o.code,l,f),f+=a,i!=null&&(s.size===V&&(encodeUint8Array(c,l,f),f+=d),l.set(i,f)),o.bytes=l}r.push(o.bytes),e+=o.bytes.byteLength}return concat(r,e)}function stringToComponents(t){var s;if(t.charAt(0)!=="/")throw new InvalidMultiaddrError('String multiaddr must start with "/"');const e=[];let r="protocol",n="",o="";for(let a=1;a<t.length;a++){const i=t.charAt(a);i!=="/"&&(r==="protocol"?o+=t.charAt(a):n+=t.charAt(a));const c=a===t.length-1;if(i==="/"||c){const d=registry.getProtocol(o);if(r==="protocol"){if(d.size==null||d.size===0){e.push({code:d.code,name:d.name}),n="",o="",r="protocol";continue}else if(c)throw new InvalidMultiaddrError(`Component ${o} was missing value`);r="value"}else if(r==="value"){const l={code:d.code,name:d.name};if(d.size!=null&&d.size!==0){if(n==="")throw new InvalidMultiaddrError(`Component ${o} was missing value`);l.value=((s=d.stringToValue)==null?void 0:s.call(d,n))??n}e.push(l),n="",o="",r="protocol"}}}if(o!==""&&n!=="")throw new InvalidMultiaddrError("Incomplete multiaddr");return e}function componentsToString(t){return`/${t.flatMap(e=>{var n;if(e.value==null)return e.name;const r=registry.getProtocol(e.code);if(r==null)throw new InvalidMultiaddrError(`Unknown protocol code ${e.code}`);return[e.name,((n=r.valueToString)==null?void 0:n.call(r,e.value))??e.value]}).join("/")}`}function sizeForAddr(t,e,r){return t.size==null||t.size===0?0:t.size>0?t.size/8:decode(e,r)}const inspect$1=Symbol.for("nodejs.util.inspect.custom"),symbol$1=Symbol.for("@multiformats/multiaddr"),DNS_CODES=[CODE_DNS,CODE_DNS4,CODE_DNS6,CODE_DNSADDR];class NoAvailableResolverError extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function toComponents(t){if(t==null&&(t="/"),isMultiaddr(t))return t.getComponents();if(t instanceof Uint8Array)return bytesToComponents(t);if(typeof t=="string")return t=t.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),t===""&&(t="/"),stringToComponents(t);if(Array.isArray(t))return t;throw new InvalidMultiaddrError("Must be a string, Uint8Array, Component[], or another Multiaddr")}var q,_,N,k;const U=class U{constructor(e="/",r={}){P(this,q,!0);R(this,_);R(this,N);R(this,k);M(this,_,toComponents(e)),r.validate!==!1&&validate(this)}get bytes(){return x(this,k)==null&&M(this,k,componentsToBytes(x(this,_))),x(this,k)}toString(){return x(this,N)==null&&M(this,N,componentsToString(x(this,_))),x(this,N)}toJSON(){return this.toString()}toOptions(){let e,r,n,o,s="";for(const{code:i,name:c,value:d}of x(this,_))i===CODE_IP6ZONE&&(s=`%${d??""}`),DNS_CODES.includes(i)&&(r="tcp",o=443,n=`${d??""}${s}`,e=i===CODE_DNS6?6:4),(i===CODE_TCP||i===CODE_UDP)&&(r=c==="tcp"?"tcp":"udp",o=parseInt(d??"")),(i===CODE_IP4||i===CODE_IP6)&&(r="tcp",n=`${d??""}${s}`,e=i===CODE_IP6?6:4);if(e==null||r==null||n==null||o==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:r,port:o}}getComponents(){return[...x(this,_)]}protos(){return x(this,_).map(({code:e,value:r})=>{const n=registry.getProtocol(e);return{code:e,size:n.size??0,name:n.name,resolvable:!!n.resolvable,path:!!n.path}})}protoCodes(){return x(this,_).map(({code:e})=>e)}protoNames(){return x(this,_).map(({name:e})=>e)}tuples(){return x(this,_).map(({code:e,value:r})=>{var s;if(r==null)return[e];const n=registry.getProtocol(e),o=[e];return r!=null&&o.push(((s=n.valueToBytes)==null?void 0:s.call(n,r))??fromString(r)),o})}stringTuples(){return x(this,_).map(({code:e,value:r})=>r==null?[e]:[e,r])}encapsulate(e){const r=new U(e);return new U([...x(this,_),...r.getComponents()],{validate:!1})}decapsulate(e){const r=e.toString(),n=this.toString(),o=n.lastIndexOf(r);if(o<0)throw new InvalidParametersError(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new U(n.slice(0,o),{validate:!1})}decapsulateCode(e){let r;for(let n=x(this,_).length-1;n>-1;n--)if(x(this,_)[n].code===e){r=n;break}return new U(x(this,_).slice(0,r),{validate:!1})}getPeerId(){try{let e=[];x(this,_).forEach(({code:n,value:o})=>{n===CODE_P2P&&e.push([n,o]),n===CODE_P2P_CIRCUIT&&(e=[])});const r=e.pop();if((r==null?void 0:r[1])!=null){const n=r[1];return n[0]==="Q"||n[0]==="1"?toString(base58btc.decode(`z${n}`),"base58btc"):toString(CID.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){for(const e of x(this,_))if(registry.getProtocol(e.code).path)return e.value??null;return null}equals(e){return equals(this.bytes,e.bytes)}async resolve(e){const r=this.protos().find(s=>s.resolvable);if(r==null)return[this];const n=resolvers.get(r.name);if(n==null)throw new NoAvailableResolverError(`no available resolver for ${r.name}`);return(await n(this,e)).map(s=>multiaddr(s))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return!(x(this,_).length!==2||x(this,_)[0].code!==CODE_IP4&&x(this,_)[0].code!==CODE_IP6||x(this,_)[1].code!==CODE_TCP&&x(this,_)[1].code!==CODE_UDP)}[(q=symbol$1,inspect$1)](){return`Multiaddr(${this.toString()})`}};_=new WeakMap,N=new WeakMap,k=new WeakMap;let Multiaddr=U;function validate(t){t.getComponents().forEach(e=>{var n;const r=registry.getProtocol(e.code);e.value!=null&&((n=r.validate)==null||n.call(r,e.value))})}const resolvers=new Map;function isMultiaddr(t){return!!(t!=null&&t[symbol$1])}function multiaddr(t){return new Multiaddr(t)}function protocols(t){const e=registry.getProtocol(t);return{code:e.code,size:e.size??0,name:e.name,resolvable:!!e.resolvable,path:!!e.path}}function extractSNI(t){let e;try{e=protocols("sni").code}catch{return null}for(const[r,n]of t)if(r===e&&n!==void 0)return n;return null}function hasTLS(t){return t.some(([e,r])=>e===protocols("tls").code)}function interpretNext(t,e,r){const n=interpreters[protocols(t).name];if(n===void 0)throw new Error(`Can't interpret protocol ${protocols(t).name}`);const o=n(e,r);return t===protocols("ip6").code?`[${o}]`:o}const interpreters={ip4:(t,e)=>t,ip6:(t,e)=>e.length===0?t:`[${t}]`,tcp:(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");return`tcp://${interpretNext(r[0],r[1]??"",e)}:${t}`},udp:(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");return`udp://${interpretNext(r[0],r[1]??"",e)}:${t}`},dnsaddr:(t,e)=>t,dns4:(t,e)=>t,dns6:(t,e)=>t,dns:(t,e)=>t,ipfs:(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");return`${interpretNext(r[0],r[1]??"",e)}/ipfs/${t}`},p2p:(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");return`${interpretNext(r[0],r[1]??"",e)}/p2p/${t}`},http:(t,e)=>{const r=hasTLS(e),n=extractSNI(e);if(r&&n!==null)return`https://${n}`;const o=r?"https://":"http://",s=e.pop();if(s===void 0)throw new Error("Unexpected end of multiaddr");let a=interpretNext(s[0],s[1]??"",e);return a=a.replace("tcp://",""),`${o}${a}`},tls:(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");return interpretNext(r[0],r[1]??"",e)},sni:(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");return interpretNext(r[0],r[1]??"",e)},https:(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");let n=interpretNext(r[0],r[1]??"",e);return n=n.replace("tcp://",""),`https://${n}`},ws:(t,e)=>{const r=hasTLS(e),n=extractSNI(e);if(r&&n!==null)return`wss://${n}`;const o=r?"wss://":"ws://",s=e.pop();if(s===void 0)throw new Error("Unexpected end of multiaddr");let a=interpretNext(s[0],s[1]??"",e);return a=a.replace("tcp://",""),`${o}${a}`},wss:(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");let n=interpretNext(r[0],r[1]??"",e);return n=n.replace("tcp://",""),`wss://${n}`},"p2p-websocket-star":(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");return`${interpretNext(r[0],r[1]??"",e)}/p2p-websocket-star`},"p2p-webrtc-star":(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");return`${interpretNext(r[0],r[1]??"",e)}/p2p-webrtc-star`},"p2p-webrtc-direct":(t,e)=>{const r=e.pop();if(r===void 0)throw new Error("Unexpected end of multiaddr");return`${interpretNext(r[0],r[1]??"",e)}/p2p-webrtc-direct`}};function multiaddrToUri(t,e){const n=multiaddr(t).stringTuples(),o=n.pop();if(o===void 0)throw new Error("Unexpected end of multiaddr");const s=protocols(o[0]),a=interpreters[s.name];if(a==null)throw new Error(`No interpreter found for ${s.name}`);let i=a(o[1]??"",n);return o[0]===protocols("tcp").code&&(i=i.replace("tcp://","http://"),(o[1]==="443"||o[1]==="80")&&(o[1]==="443"&&(i=i.replace("http://","https://")),i=i.substring(0,i.lastIndexOf(":")))),i}function toUrlString(t){try{t=multiaddrToUri(multiaddr$1(t))}catch{}return t=t.toString(),t}const getAgent=()=>{},log$1=logger("ipfs-http-client:lib:error-handler"),merge=mergeOpts.bind({ignoreUndefined:!0}),DEFAULT_PROTOCOL=env.isBrowser||env.isWebWorker?location.protocol:"http",DEFAULT_HOST=env.isBrowser||env.isWebWorker?location.hostname:"localhost",DEFAULT_PORT=env.isBrowser||env.isWebWorker?location.port:"5001",normalizeOptions=(t={})=>{let e,r={},n;if(typeof t=="string"||isMultiaddr$1(t))e=new URL(toUrlString(t));else if(t instanceof URL)e=t;else if(typeof t.url=="string"||isMultiaddr$1(t.url))e=new URL(toUrlString(t.url)),r=t;else if(t.url instanceof URL)e=t.url,r=t;else{r=t||{};const o=(r.protocol||DEFAULT_PROTOCOL).replace(":",""),s=(r.host||DEFAULT_HOST).split(":")[0],a=r.port||DEFAULT_PORT;e=new URL(`${o}://${s}:${a}`)}if(r.apiPath?e.pathname=r.apiPath:(e.pathname==="/"||e.pathname===void 0)&&(e.pathname="api/v0"),env.isNode){const o=getAgent();n=r.agent||new o({keepAlive:!0,maxSockets:6})}return{...r,host:e.host,protocol:e.protocol.replace(":",""),port:Number(e.port),apiPath:e.pathname,url:e,agent:n}},errorHandler=async t=>{let e;try{if((t.headers.get("Content-Type")||"").startsWith("application/json")){const n=await t.json();log$1(n),e=n.Message||n.message}else e=await t.text()}catch(n){log$1("Failed to parse error response",n),e=n.message}let r=new HTTP$1.HTTPError(t);throw e&&(e.includes("deadline has elapsed")&&(r=new HTTP$1.TimeoutError),e&&e.includes("context deadline exceeded")&&(r=new HTTP$1.TimeoutError)),e&&e.includes("request timed out")&&(r=new HTTP$1.TimeoutError),e&&(r.message=e),r},KEBAB_REGEX=/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g,kebabCase=t=>t.replace(KEBAB_REGEX,function(e){return"-"+e.toLowerCase()}),parseTimeout=t=>typeof t=="string"?parse(t):t;class Client extends HTTP$1{constructor(e={}){const r=normalizeOptions(e);super({timeout:parseTimeout(r.timeout||0)||void 0,headers:r.headers,base:`${r.url}`,handleError:errorHandler,transformSearchParams:o=>{const s=new URLSearchParams;for(const[a,i]of o)i!=="undefined"&&i!=="null"&&a!=="signal"&&s.append(kebabCase(a),i),a==="timeout"&&!isNaN(i)&&s.append(kebabCase(a),i);return s},agent:r.agent}),delete this.get,delete this.put,delete this.delete,delete this.options;const n=this.fetch;this.fetch=(o,s={})=>(typeof o=="string"&&!o.startsWith("/")&&(o=`${r.url}/${o}`),n.call(this,o,merge(s,{method:"POST"})))}}HTTP$1.HTTPError;const configure=t=>e=>t(new Client(e),e);function modeToString$1(t){if(t!=null)return typeof t=="string"?t:t.toString(8).padStart(4,"0")}function parseMtime$1(t){if(t==null)return;let e;if(t.secs!=null&&(e={secs:t.secs,nsecs:t.nsecs}),t.Seconds!=null&&(e={secs:t.Seconds,nsecs:t.FractionalNanoseconds}),Array.isArray(t)&&(e={secs:t[0],nsecs:t[1]}),t instanceof Date){const r=t.getTime(),n=Math.floor(r/1e3);e={secs:n,nsecs:(r-n*1e3)*1e3}}if(Object.prototype.hasOwnProperty.call(e,"secs")){if(e!=null&&e.nsecs!=null&&(e.nsecs<0||e.nsecs>999999999))throw errCode$1(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return e}}function toUrlSearchParams({arg:t,searchParams:e,hashAlg:r,mtime:n,mode:o,...s}={}){e&&(s={...s,...e}),r&&(s.hash=r),n!=null&&(n=parseMtime$1(n),s.mtime=n.secs,s.mtimeNsecs=n.nsecs),o!=null&&(s.mode=modeToString$1(o)),s.timeout&&!isNaN(s.timeout)&&(s.timeout=`${s.timeout}ms`),t==null?t=[]:Array.isArray(t)||(t=[t]);const a=new URLSearchParams(s);return t.forEach(i=>a.append("arg",i)),a}const createWantlist=configure(t=>{async function e(r={}){return((await(await t.post("bitswap/wantlist",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json()).Keys||[]).map(o=>CID$2.parse(o["/"]))}return e}),createWantlistForPeer=configure(t=>{async function e(r,n={}){return((await(await t.post("bitswap/wantlist",{signal:n.signal,searchParams:toUrlSearchParams({...n,peer:r.toString()}),headers:n.headers})).json()).Keys||[]).map(s=>CID$2.parse(s["/"]))}return e}),symbol=Symbol.for("@libp2p/peer-id"),inspect=Symbol.for("nodejs.util.inspect.custom"),baseDecoder=Object.values(bases$3).map(t=>t.decoder).reduce((t,e)=>t.or(e),bases$3.identity.decoder),LIBP2P_KEY_CODE=114,MARSHALLED_ED225519_PUBLIC_KEY_LENGTH=36,MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH=37;class PeerIdImpl{constructor(e){this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}get[symbol](){return!0}toString(){return this.string==null&&(this.string=base58btc$4.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return CID$2.createV1(LIBP2P_KEY_CODE,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){var r;if(e instanceof Uint8Array)return equals$3(this.multihash.bytes,e);if(typeof e=="string")return peerIdFromString(e).equals(this);if(((r=e==null?void 0:e.multihash)==null?void 0:r.bytes)!=null)return equals$3(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[inspect](){return`PeerId(${this.toString()})`}}class RSAPeerIdImpl extends PeerIdImpl{constructor(e){super({...e,type:"RSA"}),this.type="RSA",this.publicKey=e.publicKey}}class Ed25519PeerIdImpl extends PeerIdImpl{constructor(e){super({...e,type:"Ed25519"}),this.type="Ed25519",this.publicKey=e.multihash.digest}}class Secp256k1PeerIdImpl extends PeerIdImpl{constructor(e){super({...e,type:"secp256k1"}),this.type="secp256k1",this.publicKey=e.multihash.digest}}function peerIdFromString(t,e){if(t.charAt(0)==="1"||t.charAt(0)==="Q"){const r=decode$l(base58btc$4.decode(`z${t}`));return t.startsWith("12D")?new Ed25519PeerIdImpl({multihash:r}):t.startsWith("16U")?new Secp256k1PeerIdImpl({multihash:r}):new RSAPeerIdImpl({multihash:r})}return peerIdFromBytes(baseDecoder.decode(t))}function peerIdFromBytes(t){try{const e=decode$l(t);if(e.code===identity$4.code){if(e.digest.length===MARSHALLED_ED225519_PUBLIC_KEY_LENGTH)return new Ed25519PeerIdImpl({multihash:e});if(e.digest.length===MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH)return new Secp256k1PeerIdImpl({multihash:e})}if(e.code===sha256.code)return new RSAPeerIdImpl({multihash:e})}catch{return peerIdFromCID(CID$2.decode(t))}throw new Error("Supplied PeerID CID is invalid")}function peerIdFromCID(t){if(t==null||t.multihash==null||t.version==null||t.version===1&&t.code!==LIBP2P_KEY_CODE)throw new Error("Supplied PeerID CID is invalid");const e=t.multihash;if(e.code===sha256.code)return new RSAPeerIdImpl({multihash:t.multihash});if(e.code===identity$4.code){if(e.digest.length===MARSHALLED_ED225519_PUBLIC_KEY_LENGTH)return new Ed25519PeerIdImpl({multihash:t.multihash});if(e.digest.length===MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH)return new Secp256k1PeerIdImpl({multihash:t.multihash})}throw new Error("Supplied PeerID CID is invalid")}const createStat$4=configure(t=>{async function e(r={}){const n=await t.post("bitswap/stat",{searchParams:toUrlSearchParams(r),signal:r.signal,headers:r.headers});return toCoreInterface$4(await n.json())}return e});function toCoreInterface$4(t){return{provideBufLen:t.ProvideBufLen,wantlist:(t.Wantlist||[]).map(e=>CID$2.parse(e["/"])),peers:(t.Peers||[]).map(e=>peerIdFromString(e)),blocksReceived:BigInt(t.BlocksReceived),dataReceived:BigInt(t.DataReceived),blocksSent:BigInt(t.BlocksSent),dataSent:BigInt(t.DataSent),dupBlksReceived:BigInt(t.DupBlksReceived),dupDataReceived:BigInt(t.DupDataReceived)}}const createUnwant=configure(t=>{async function e(r,n={}){return(await t.post("bitswap/unwant",{signal:n.signal,searchParams:toUrlSearchParams({arg:r.toString(),...n}),headers:n.headers})).json()}return e});function createBitswap(t){return{wantlist:createWantlist(t),wantlistForPeer:createWantlistForPeer(t),unwant:createUnwant(t),stat:createStat$4(t)}}const createGet$5=configure(t=>{async function e(r,n={}){const o=await t.post("block/get",{signal:n.signal,searchParams:toUrlSearchParams({arg:r.toString(),...n}),headers:n.headers});return new Uint8Array(await o.arrayBuffer())}return e});function peekableIterator(t){const[e,r]=t[Symbol.asyncIterator]!=null?[t[Symbol.asyncIterator](),Symbol.asyncIterator]:[t[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:o=>{n.push(o)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[r](){return this}}}async function*browserReadableStreamToIt(t,e={}){const r=t.getReader();try{for(;;){const n=await r.read();if(n.done)return;yield n.value}}finally{e.preventCancel!==!0&&await r.cancel(),r.releaseLock()}}async function all(t){const e=[];for await(const r of t)e.push(r);return e}function isBytes(t){return ArrayBuffer.isView(t)||t instanceof ArrayBuffer}function isBlob(t){return t.constructor&&(t.constructor.name==="Blob"||t.constructor.name==="File")&&typeof t.stream=="function"}function isFileObject(t){return typeof t=="object"&&(t.path||t.content)}const isReadableStream=t=>t&&typeof t.getReader=="function";async function normaliseContent$1(t){if(isBytes(t))return new Blob([t]);if(typeof t=="string"||t instanceof String)return new Blob([t.toString()]);if(isBlob(t))return t;if(isReadableStream(t)&&(t=browserReadableStreamToIt(t)),Symbol.iterator in t||Symbol.asyncIterator in t){const e=peekableIterator(t),{value:r,done:n}=await e.peek();if(n)return itToBlob(e);if(e.push(r),Number.isInteger(r))return new Blob([Uint8Array.from(await all(e))]);if(isBytes(r)||typeof r=="string"||r instanceof String)return itToBlob(e)}throw errCode$1(new Error(`Unexpected input: ${t}`),"ERR_UNEXPECTED_INPUT")}async function itToBlob(t){const e=[];for await(const r of t)e.push(r);return new Blob(e)}async function*map(t,e){for await(const r of t)yield e(r)}var indexMinimal={},minimal$1={},aspromise=asPromise;function asPromise(t,e){for(var r=new Array(arguments.length-1),n=0,o=2,s=!0;o<arguments.length;)r[n++]=arguments[o++];return new Promise(function(i,c){r[n]=function(l){if(s)if(s=!1,l)c(l);else{for(var f=new Array(arguments.length-1),p=0;p<f.length;)f[p++]=arguments[p];i.apply(null,f)}};try{t.apply(e||null,r)}catch(d){s&&(s=!1,c(d))}})}var base64$1={};(function(t){var e=t;e.length=function(i){var c=i.length;if(!c)return 0;for(var d=0;--c%4>1&&i.charAt(c)==="=";)++d;return Math.ceil(i.length*3)/4-d};for(var r=new Array(64),n=new Array(123),o=0;o<64;)n[r[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;e.encode=function(i,c,d){for(var l=null,f=[],p=0,v=0,u;c<d;){var h=i[c++];switch(v){case 0:f[p++]=r[h>>2],u=(h&3)<<4,v=1;break;case 1:f[p++]=r[u|h>>4],u=(h&15)<<2,v=2;break;case 2:f[p++]=r[u|h>>6],f[p++]=r[h&63],v=0;break}p>8191&&((l||(l=[])).push(String.fromCharCode.apply(String,f)),p=0)}return v&&(f[p++]=r[u],f[p++]=61,v===1&&(f[p++]=61)),l?(p&&l.push(String.fromCharCode.apply(String,f.slice(0,p))),l.join("")):String.fromCharCode.apply(String,f.slice(0,p))};var s="invalid encoding";e.decode=function(i,c,d){for(var l=d,f=0,p,v=0;v<i.length;){var u=i.charCodeAt(v++);if(u===61&&f>1)break;if((u=n[u])===void 0)throw Error(s);switch(f){case 0:p=u,f=1;break;case 1:c[d++]=p<<2|(u&48)>>4,p=u,f=2;break;case 2:c[d++]=(p&15)<<4|(u&60)>>2,p=u,f=3;break;case 3:c[d++]=(p&3)<<6|u,f=0;break}}if(f===1)throw Error(s);return d-l},e.test=function(i){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(i)}})(base64$1);var eventemitter=EventEmitter;function EventEmitter(){this._listeners={}}EventEmitter.prototype.on=function(e,r,n){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:r,ctx:n||this}),this};EventEmitter.prototype.off=function(e,r){if(e===void 0)this._listeners={};else if(r===void 0)this._listeners[e]=[];else for(var n=this._listeners[e],o=0;o<n.length;)n[o].fn===r?n.splice(o,1):++o;return this};EventEmitter.prototype.emit=function(e){var r=this._listeners[e];if(r){for(var n=[],o=1;o<arguments.length;)n.push(arguments[o++]);for(o=0;o<r.length;)r[o].fn.apply(r[o++].ctx,n)}return this};var float=factory(factory);function factory(t){return typeof Float32Array<"u"?function(){var e=new Float32Array([-0]),r=new Uint8Array(e.buffer),n=r[3]===128;function o(c,d,l){e[0]=c,d[l]=r[0],d[l+1]=r[1],d[l+2]=r[2],d[l+3]=r[3]}function s(c,d,l){e[0]=c,d[l]=r[3],d[l+1]=r[2],d[l+2]=r[1],d[l+3]=r[0]}t.writeFloatLE=n?o:s,t.writeFloatBE=n?s:o;function a(c,d){return r[0]=c[d],r[1]=c[d+1],r[2]=c[d+2],r[3]=c[d+3],e[0]}function i(c,d){return r[3]=c[d],r[2]=c[d+1],r[1]=c[d+2],r[0]=c[d+3],e[0]}t.readFloatLE=n?a:i,t.readFloatBE=n?i:a}():function(){function e(n,o,s,a){var i=o<0?1:0;if(i&&(o=-o),o===0)n(1/o>0?0:2147483648,s,a);else if(isNaN(o))n(2143289344,s,a);else if(o>34028234663852886e22)n((i<<31|2139095040)>>>0,s,a);else if(o<11754943508222875e-54)n((i<<31|Math.round(o/1401298464324817e-60))>>>0,s,a);else{var c=Math.floor(Math.log(o)/Math.LN2),d=Math.round(o*Math.pow(2,-c)*8388608)&8388607;n((i<<31|c+127<<23|d)>>>0,s,a)}}t.writeFloatLE=e.bind(null,writeUintLE),t.writeFloatBE=e.bind(null,writeUintBE);function r(n,o,s){var a=n(o,s),i=(a>>31)*2+1,c=a>>>23&255,d=a&8388607;return c===255?d?NaN:i*(1/0):c===0?i*1401298464324817e-60*d:i*Math.pow(2,c-150)*(d+8388608)}t.readFloatLE=r.bind(null,readUintLE),t.readFloatBE=r.bind(null,readUintBE)}(),typeof Float64Array<"u"?function(){var e=new Float64Array([-0]),r=new Uint8Array(e.buffer),n=r[7]===128;function o(c,d,l){e[0]=c,d[l]=r[0],d[l+1]=r[1],d[l+2]=r[2],d[l+3]=r[3],d[l+4]=r[4],d[l+5]=r[5],d[l+6]=r[6],d[l+7]=r[7]}function s(c,d,l){e[0]=c,d[l]=r[7],d[l+1]=r[6],d[l+2]=r[5],d[l+3]=r[4],d[l+4]=r[3],d[l+5]=r[2],d[l+6]=r[1],d[l+7]=r[0]}t.writeDoubleLE=n?o:s,t.writeDoubleBE=n?s:o;function a(c,d){return r[0]=c[d],r[1]=c[d+1],r[2]=c[d+2],r[3]=c[d+3],r[4]=c[d+4],r[5]=c[d+5],r[6]=c[d+6],r[7]=c[d+7],e[0]}function i(c,d){return r[7]=c[d],r[6]=c[d+1],r[5]=c[d+2],r[4]=c[d+3],r[3]=c[d+4],r[2]=c[d+5],r[1]=c[d+6],r[0]=c[d+7],e[0]}t.readDoubleLE=n?a:i,t.readDoubleBE=n?i:a}():function(){function e(n,o,s,a,i,c){var d=a<0?1:0;if(d&&(a=-a),a===0)n(0,i,c+o),n(1/a>0?0:2147483648,i,c+s);else if(isNaN(a))n(0,i,c+o),n(2146959360,i,c+s);else if(a>17976931348623157e292)n(0,i,c+o),n((d<<31|2146435072)>>>0,i,c+s);else{var l;if(a<22250738585072014e-324)l=a/5e-324,n(l>>>0,i,c+o),n((d<<31|l/4294967296)>>>0,i,c+s);else{var f=Math.floor(Math.log(a)/Math.LN2);f===1024&&(f=1023),l=a*Math.pow(2,-f),n(l*4503599627370496>>>0,i,c+o),n((d<<31|f+1023<<20|l*1048576&1048575)>>>0,i,c+s)}}}t.writeDoubleLE=e.bind(null,writeUintLE,0,4),t.writeDoubleBE=e.bind(null,writeUintBE,4,0);function r(n,o,s,a,i){var c=n(a,i+o),d=n(a,i+s),l=(d>>31)*2+1,f=d>>>20&2047,p=4294967296*(d&1048575)+c;return f===2047?p?NaN:l*(1/0):f===0?l*5e-324*p:l*Math.pow(2,f-1075)*(p+4503599627370496)}t.readDoubleLE=r.bind(null,readUintLE,0,4),t.readDoubleBE=r.bind(null,readUintBE,4,0)}(),t}function writeUintLE(t,e,r){e[r]=t&255,e[r+1]=t>>>8&255,e[r+2]=t>>>16&255,e[r+3]=t>>>24}function writeUintBE(t,e,r){e[r]=t>>>24,e[r+1]=t>>>16&255,e[r+2]=t>>>8&255,e[r+3]=t&255}function readUintLE(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}function readUintBE(t,e){return(t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3])>>>0}var inquire_1=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}var utf8$2={};(function(t){var e=t;e.length=function(n){for(var o=0,s=0,a=0;a<n.length;++a)s=n.charCodeAt(a),s<128?o+=1:s<2048?o+=2:(s&64512)===55296&&(n.charCodeAt(a+1)&64512)===56320?(++a,o+=4):o+=3;return o},e.read=function(n,o,s){var a=s-o;if(a<1)return"";for(var i=null,c=[],d=0,l;o<s;)l=n[o++],l<128?c[d++]=l:l>191&&l<224?c[d++]=(l&31)<<6|n[o++]&63:l>239&&l<365?(l=((l&7)<<18|(n[o++]&63)<<12|(n[o++]&63)<<6|n[o++]&63)-65536,c[d++]=55296+(l>>10),c[d++]=56320+(l&1023)):c[d++]=(l&15)<<12|(n[o++]&63)<<6|n[o++]&63,d>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,c)),d=0);return i?(d&&i.push(String.fromCharCode.apply(String,c.slice(0,d))),i.join("")):String.fromCharCode.apply(String,c.slice(0,d))},e.write=function(n,o,s){for(var a=s,i,c,d=0;d<n.length;++d)i=n.charCodeAt(d),i<128?o[s++]=i:i<2048?(o[s++]=i>>6|192,o[s++]=i&63|128):(i&64512)===55296&&((c=n.charCodeAt(d+1))&64512)===56320?(i=65536+((i&1023)<<10)+(c&1023),++d,o[s++]=i>>18|240,o[s++]=i>>12&63|128,o[s++]=i>>6&63|128,o[s++]=i&63|128):(o[s++]=i>>12|224,o[s++]=i>>6&63|128,o[s++]=i&63|128);return s-a}})(utf8$2);var pool_1=pool;function pool(t,e,r){var n=r||8192,o=n>>>1,s=null,a=n;return function(c){if(c<1||c>o)return t(c);a+c>n&&(s=t(n),a=0);var d=e.call(s,a,a+=c);return a&7&&(a=(a|7)+1),d}}var longbits,hasRequiredLongbits;function requireLongbits(){if(hasRequiredLongbits)return longbits;hasRequiredLongbits=1,longbits=e;var t=requireMinimal();function e(s,a){this.lo=s>>>0,this.hi=a>>>0}var r=e.zero=new e(0,0);r.toNumber=function(){return 0},r.zzEncode=r.zzDecode=function(){return this},r.length=function(){return 1};var n=e.zeroHash="\0\0\0\0\0\0\0\0";e.fromNumber=function(a){if(a===0)return r;var i=a<0;i&&(a=-a);var c=a>>>0,d=(a-c)/4294967296>>>0;return i&&(d=~d>>>0,c=~c>>>0,++c>4294967295&&(c=0,++d>4294967295&&(d=0))),new e(c,d)},e.from=function(a){if(typeof a=="number")return e.fromNumber(a);if(t.isString(a))if(t.Long)a=t.Long.fromString(a);else return e.fromNumber(parseInt(a,10));return a.low||a.high?new e(a.low>>>0,a.high>>>0):r},e.prototype.toNumber=function(a){if(!a&&this.hi>>>31){var i=~this.lo+1>>>0,c=~this.hi>>>0;return i||(c=c+1>>>0),-(i+c*4294967296)}return this.lo+this.hi*4294967296},e.prototype.toLong=function(a){return t.Long?new t.Long(this.lo|0,this.hi|0,!!a):{low:this.lo|0,high:this.hi|0,unsigned:!!a}};var o=String.prototype.charCodeAt;return e.fromHash=function(a){return a===n?r:new e((o.call(a,0)|o.call(a,1)<<8|o.call(a,2)<<16|o.call(a,3)<<24)>>>0,(o.call(a,4)|o.call(a,5)<<8|o.call(a,6)<<16|o.call(a,7)<<24)>>>0)},e.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},e.prototype.zzEncode=function(){var a=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^a)>>>0,this.lo=(this.lo<<1^a)>>>0,this},e.prototype.zzDecode=function(){var a=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^a)>>>0,this.hi=(this.hi>>>1^a)>>>0,this},e.prototype.length=function(){var a=this.lo,i=(this.lo>>>28|this.hi<<4)>>>0,c=this.hi>>>24;return c===0?i===0?a<16384?a<128?1:2:a<2097152?3:4:i<16384?i<128?5:6:i<2097152?7:8:c<128?9:10},longbits}var hasRequiredMinimal;function requireMinimal(){return hasRequiredMinimal||(hasRequiredMinimal=1,function(t){var e=t;e.asPromise=aspromise,e.base64=base64$1,e.EventEmitter=eventemitter,e.float=float,e.inquire=inquire_1,e.utf8=utf8$2,e.pool=pool_1,e.LongBits=requireLongbits(),e.isNode=!!(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),e.global=e.isNode&&commonjsGlobal||typeof window<"u"&&window||typeof self<"u"&&self||commonjsGlobal,e.emptyArray=Object.freeze?Object.freeze([]):[],e.emptyObject=Object.freeze?Object.freeze({}):{},e.isInteger=Number.isInteger||function(s){return typeof s=="number"&&isFinite(s)&&Math.floor(s)===s},e.isString=function(s){return typeof s=="string"||s instanceof String},e.isObject=function(s){return s&&typeof s=="object"},e.isset=e.isSet=function(s,a){var i=s[a];return i!=null&&s.hasOwnProperty(a)?typeof i!="object"||(Array.isArray(i)?i.length:Object.keys(i).length)>0:!1},e.Buffer=function(){try{var o=e.inquire("buffer").Buffer;return o.prototype.utf8Write?o:null}catch{return null}}(),e._Buffer_from=null,e._Buffer_allocUnsafe=null,e.newBuffer=function(s){return typeof s=="number"?e.Buffer?e._Buffer_allocUnsafe(s):new e.Array(s):e.Buffer?e._Buffer_from(s):typeof Uint8Array>"u"?s:new Uint8Array(s)},e.Array=typeof Uint8Array<"u"?Uint8Array:Array,e.Long=e.global.dcodeIO&&e.global.dcodeIO.Long||e.global.Long||e.inquire("long"),e.key2Re=/^true|false|0|1$/,e.key32Re=/^-?(?:0|[1-9][0-9]*)$/,e.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,e.longToHash=function(s){return s?e.LongBits.from(s).toHash():e.LongBits.zeroHash},e.longFromHash=function(s,a){var i=e.LongBits.fromHash(s);return e.Long?e.Long.fromBits(i.lo,i.hi,a):i.toNumber(!!a)};function r(o,s,a){for(var i=Object.keys(s),c=0;c<i.length;++c)(o[i[c]]===void 0||!a)&&(o[i[c]]=s[i[c]]);return o}e.merge=r,e.lcFirst=function(s){return s.charAt(0).toLowerCase()+s.substring(1)};function n(o){function s(a,i){if(!(this instanceof s))return new s(a,i);Object.defineProperty(this,"message",{get:function(){return a}}),Error.captureStackTrace?Error.captureStackTrace(this,s):Object.defineProperty(this,"stack",{value:new Error().stack||""}),i&&r(this,i)}return s.prototype=Object.create(Error.prototype,{constructor:{value:s,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return o},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),s}e.newError=n,e.ProtocolError=n("ProtocolError"),e.oneOfGetter=function(s){for(var a={},i=0;i<s.length;++i)a[s[i]]=1;return function(){for(var c=Object.keys(this),d=c.length-1;d>-1;--d)if(a[c[d]]===1&&this[c[d]]!==void 0&&this[c[d]]!==null)return c[d]}},e.oneOfSetter=function(s){return function(a){for(var i=0;i<s.length;++i)s[i]!==a&&delete this[s[i]]}},e.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},e._configure=function(){var o=e.Buffer;if(!o){e._Buffer_from=e._Buffer_allocUnsafe=null;return}e._Buffer_from=o.from!==Uint8Array.from&&o.from||function(a,i){return new o(a,i)},e._Buffer_allocUnsafe=o.allocUnsafe||function(a){return new o(a)}}}(minimal$1)),minimal$1}var writer=Writer$1,util$4=requireMinimal(),BufferWriter$1,LongBits$1=util$4.LongBits,base64=util$4.base64,utf8$1=util$4.utf8;function Op(t,e,r){this.fn=t,this.len=e,this.next=void 0,this.val=r}function noop(){}function State(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function Writer$1(){this.len=0,this.head=new Op(noop,0,0),this.tail=this.head,this.states=null}var create$2=function t(){return util$4.Buffer?function(){return(Writer$1.create=function(){return new BufferWriter$1})()}:function(){return new Writer$1}};Writer$1.create=create$2();Writer$1.alloc=function t(e){return new util$4.Array(e)};util$4.Array!==Array&&(Writer$1.alloc=util$4.pool(Writer$1.alloc,util$4.Array.prototype.subarray));Writer$1.prototype._push=function t(e,r,n){return this.tail=this.tail.next=new Op(e,r,n),this.len+=r,this};function writeByte(t,e,r){e[r]=t&255}function writeVarint32(t,e,r){for(;t>127;)e[r++]=t&127|128,t>>>=7;e[r]=t}function VarintOp(t,e){this.len=t,this.next=void 0,this.val=e}VarintOp.prototype=Object.create(Op.prototype);VarintOp.prototype.fn=writeVarint32;Writer$1.prototype.uint32=function t(e){return this.len+=(this.tail=this.tail.next=new VarintOp((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this};Writer$1.prototype.int32=function t(e){return e<0?this._push(writeVarint64,10,LongBits$1.fromNumber(e)):this.uint32(e)};Writer$1.prototype.sint32=function t(e){return this.uint32((e<<1^e>>31)>>>0)};function writeVarint64(t,e,r){for(;t.hi;)e[r++]=t.lo&127|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[r++]=t.lo&127|128,t.lo=t.lo>>>7;e[r++]=t.lo}Writer$1.prototype.uint64=function t(e){var r=LongBits$1.from(e);return this._push(writeVarint64,r.length(),r)};Writer$1.prototype.int64=Writer$1.prototype.uint64;Writer$1.prototype.sint64=function t(e){var r=LongBits$1.from(e).zzEncode();return this._push(writeVarint64,r.length(),r)};Writer$1.prototype.bool=function t(e){return this._push(writeByte,1,e?1:0)};function writeFixed32(t,e,r){e[r]=t&255,e[r+1]=t>>>8&255,e[r+2]=t>>>16&255,e[r+3]=t>>>24}Writer$1.prototype.fixed32=function t(e){return this._push(writeFixed32,4,e>>>0)};Writer$1.prototype.sfixed32=Writer$1.prototype.fixed32;Writer$1.prototype.fixed64=function t(e){var r=LongBits$1.from(e);return this._push(writeFixed32,4,r.lo)._push(writeFixed32,4,r.hi)};Writer$1.prototype.sfixed64=Writer$1.prototype.fixed64;Writer$1.prototype.float=function t(e){return this._push(util$4.float.writeFloatLE,4,e)};Writer$1.prototype.double=function t(e){return this._push(util$4.float.writeDoubleLE,8,e)};var writeBytes=util$4.Array.prototype.set?function t(e,r,n){r.set(e,n)}:function t(e,r,n){for(var o=0;o<e.length;++o)r[n+o]=e[o]};Writer$1.prototype.bytes=function t(e){var r=e.length>>>0;if(!r)return this._push(writeByte,1,0);if(util$4.isString(e)){var n=Writer$1.alloc(r=base64.length(e));base64.decode(e,n,0),e=n}return this.uint32(r)._push(writeBytes,r,e)};Writer$1.prototype.string=function t(e){var r=utf8$1.length(e);return r?this.uint32(r)._push(utf8$1.write,r,e):this._push(writeByte,1,0)};Writer$1.prototype.fork=function t(){return this.states=new State(this),this.head=this.tail=new Op(noop,0,0),this.len=0,this};Writer$1.prototype.reset=function t(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop,0,0),this.len=0),this};Writer$1.prototype.ldelim=function t(){var e=this.head,r=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=e.next,this.tail=r,this.len+=n),this};Writer$1.prototype.finish=function t(){for(var e=this.head.next,r=this.constructor.alloc(this.len),n=0;e;)e.fn(e.val,r,n),n+=e.len,e=e.next;return r};Writer$1._configure=function(t){BufferWriter$1=t,Writer$1.create=create$2(),BufferWriter$1._configure()};var writer_buffer=BufferWriter,Writer=writer;(BufferWriter.prototype=Object.create(Writer.prototype)).constructor=BufferWriter;var util$3=requireMinimal();function BufferWriter(){Writer.call(this)}BufferWriter._configure=function(){BufferWriter.alloc=util$3._Buffer_allocUnsafe,BufferWriter.writeBytesBuffer=util$3.Buffer&&util$3.Buffer.prototype instanceof Uint8Array&&util$3.Buffer.prototype.set.name==="set"?function(e,r,n){r.set(e,n)}:function(e,r,n){if(e.copy)e.copy(r,n,0,e.length);else for(var o=0;o<e.length;)r[n++]=e[o++]}};BufferWriter.prototype.bytes=function t(e){util$3.isString(e)&&(e=util$3._Buffer_from(e,"base64"));var r=e.length>>>0;return this.uint32(r),r&&this._push(BufferWriter.writeBytesBuffer,r,e),this};function writeStringBuffer(t,e,r){t.length<40?util$3.utf8.write(t,e,r):e.utf8Write?e.utf8Write(t,r):e.write(t,r)}BufferWriter.prototype.string=function t(e){var r=util$3.Buffer.byteLength(e);return this.uint32(r),r&&this._push(writeStringBuffer,r,e),this};BufferWriter._configure();var reader=Reader$1,util$2=requireMinimal(),BufferReader$1,LongBits=util$2.LongBits,utf8=util$2.utf8;function indexOutOfRange(t,e){return RangeError("index out of range: "+t.pos+" + "+(e||1)+" > "+t.len)}function Reader$1(t){this.buf=t,this.pos=0,this.len=t.length}var create_array=typeof Uint8Array<"u"?function t(e){if(e instanceof Uint8Array||Array.isArray(e))return new Reader$1(e);throw Error("illegal buffer")}:function t(e){if(Array.isArray(e))return new Reader$1(e);throw Error("illegal buffer")},create$1=function t(){return util$2.Buffer?function(r){return(Reader$1.create=function(o){return util$2.Buffer.isBuffer(o)?new BufferReader$1(o):create_array(o)})(r)}:create_array};Reader$1.create=create$1();Reader$1.prototype._slice=util$2.Array.prototype.subarray||util$2.Array.prototype.slice;Reader$1.prototype.uint32=function t(){var e=4294967295;return function(){if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return e}}();Reader$1.prototype.int32=function t(){return this.uint32()|0};Reader$1.prototype.sint32=function t(){var e=this.uint32();return e>>>1^-(e&1)|0};function readLongVarint(){var t=new LongBits(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw indexOutOfRange(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw indexOutOfRange(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}Reader$1.prototype.bool=function t(){return this.uint32()!==0};function readFixed32_end(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}Reader$1.prototype.fixed32=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)};Reader$1.prototype.sfixed32=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)|0};function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}Reader$1.prototype.float=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var e=util$2.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e};Reader$1.prototype.double=function t(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var e=util$2.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e};Reader$1.prototype.bytes=function t(){var e=this.uint32(),r=this.pos,n=this.pos+e;if(n>this.len)throw indexOutOfRange(this,e);if(this.pos+=e,Array.isArray(this.buf))return this.buf.slice(r,n);if(r===n){var o=util$2.Buffer;return o?o.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,r,n)};Reader$1.prototype.string=function t(){var e=this.bytes();return utf8.read(e,0,e.length)};Reader$1.prototype.skip=function t(e){if(typeof e=="number"){if(this.pos+e>this.len)throw indexOutOfRange(this,e);this.pos+=e}else do if(this.pos>=this.len)throw indexOutOfRange(this);while(this.buf[this.pos++]&128);return this};Reader$1.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos)}return this};Reader$1._configure=function(t){BufferReader$1=t,Reader$1.create=create$1(),BufferReader$1._configure();var e=util$2.Long?"toLong":"toNumber";util$2.merge(Reader$1.prototype,{int64:function(){return readLongVarint.call(this)[e](!1)},uint64:function(){return readLongVarint.call(this)[e](!0)},sint64:function(){return readLongVarint.call(this).zzDecode()[e](!1)},fixed64:function(){return readFixed64.call(this)[e](!0)},sfixed64:function(){return readFixed64.call(this)[e](!1)}})};var reader_buffer=BufferReader,Reader=reader;(BufferReader.prototype=Object.create(Reader.prototype)).constructor=BufferReader;var util$1=requireMinimal();function BufferReader(t){Reader.call(this,t)}BufferReader._configure=function(){util$1.Buffer&&(BufferReader.prototype._slice=util$1.Buffer.prototype.slice)};BufferReader.prototype.string=function t(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))};BufferReader._configure();var rpc={},service=Service,util=requireMinimal();(Service.prototype=Object.create(util.EventEmitter.prototype)).constructor=Service;function Service(t,e,r){if(typeof t!="function")throw TypeError("rpcImpl must be a function");util.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=!!e,this.responseDelimited=!!r}Service.prototype.rpcCall=function t(e,r,n,o,s){if(!o)throw TypeError("request must be specified");var a=this;if(!s)return util.asPromise(t,a,e,r,n,o);if(!a.rpcImpl){setTimeout(function(){s(Error("already ended"))},0);return}try{return a.rpcImpl(e,r[a.requestDelimited?"encodeDelimited":"encode"](o).finish(),function(c,d){if(c)return a.emit("error",c,e),s(c);if(d===null){a.end(!0);return}if(!(d instanceof n))try{d=n[a.responseDelimited?"decodeDelimited":"decode"](d)}catch(l){return a.emit("error",l,e),s(l)}return a.emit("data",d,e),s(null,d)})}catch(i){a.emit("error",i,e),setTimeout(function(){s(i)},0);return}};Service.prototype.end=function t(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this};(function(t){var e=t;e.Service=service})(rpc);var roots={};(function(t){var e=t;e.build="minimal",e.Writer=writer,e.BufferWriter=writer_buffer,e.Reader=reader,e.BufferReader=reader_buffer,e.util=requireMinimal(),e.rpc=rpc,e.roots=roots,e.configure=r;function r(){e.util._configure(),e.Writer._configure(e.BufferWriter),e.Reader._configure(e.BufferReader)}r()})(indexMinimal);var minimal=indexMinimal;const $protobuf=getDefaultExportFromCjs(minimal),$Reader=$protobuf.Reader,$Writer=$protobuf.Writer,$util=$protobuf.util,$root=$protobuf.roots["ipfs-unixfs"]||($protobuf.roots["ipfs-unixfs"]={});$root.Data=(()=>{function t(e){if(this.blocksizes=[],e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.Type=0,t.prototype.Data=$util.newBuffer([]),t.prototype.filesize=$util.Long?$util.Long.fromBits(0,0,!0):0,t.prototype.blocksizes=$util.emptyArray,t.prototype.hashType=$util.Long?$util.Long.fromBits(0,0,!0):0,t.prototype.fanout=$util.Long?$util.Long.fromBits(0,0,!0):0,t.prototype.mode=0,t.prototype.mtime=null,t.encode=function(r,n){if(n||(n=$Writer.create()),n.uint32(8).int32(r.Type),r.Data!=null&&Object.hasOwnProperty.call(r,"Data")&&n.uint32(18).bytes(r.Data),r.filesize!=null&&Object.hasOwnProperty.call(r,"filesize")&&n.uint32(24).uint64(r.filesize),r.blocksizes!=null&&r.blocksizes.length)for(var o=0;o<r.blocksizes.length;++o)n.uint32(32).uint64(r.blocksizes[o]);return r.hashType!=null&&Object.hasOwnProperty.call(r,"hashType")&&n.uint32(40).uint64(r.hashType),r.fanout!=null&&Object.hasOwnProperty.call(r,"fanout")&&n.uint32(48).uint64(r.fanout),r.mode!=null&&Object.hasOwnProperty.call(r,"mode")&&n.uint32(56).uint32(r.mode),r.mtime!=null&&Object.hasOwnProperty.call(r,"mtime")&&$root.UnixTime.encode(r.mtime,n.uint32(66).fork()).ldelim(),n},t.decode=function(r,n){r instanceof $Reader||(r=$Reader.create(r));for(var o=n===void 0?r.len:r.pos+n,s=new $root.Data;r.pos<o;){var a=r.uint32();switch(a>>>3){case 1:s.Type=r.int32();break;case 2:s.Data=r.bytes();break;case 3:s.filesize=r.uint64();break;case 4:if(s.blocksizes&&s.blocksizes.length||(s.blocksizes=[]),(a&7)===2)for(var i=r.uint32()+r.pos;r.pos<i;)s.blocksizes.push(r.uint64());else s.blocksizes.push(r.uint64());break;case 5:s.hashType=r.uint64();break;case 6:s.fanout=r.uint64();break;case 7:s.mode=r.uint32();break;case 8:s.mtime=$root.UnixTime.decode(r,r.uint32());break;default:r.skipType(a&7);break}}if(!s.hasOwnProperty("Type"))throw $util.ProtocolError("missing required 'Type'",{instance:s});return s},t.fromObject=function(r){if(r instanceof $root.Data)return r;var n=new $root.Data;switch(r.Type){case"Raw":case 0:n.Type=0;break;case"Directory":case 1:n.Type=1;break;case"File":case 2:n.Type=2;break;case"Metadata":case 3:n.Type=3;break;case"Symlink":case 4:n.Type=4;break;case"HAMTShard":case 5:n.Type=5;break}if(r.Data!=null&&(typeof r.Data=="string"?$util.base64.decode(r.Data,n.Data=$util.newBuffer($util.base64.length(r.Data)),0):r.Data.length&&(n.Data=r.Data)),r.filesize!=null&&($util.Long?(n.filesize=$util.Long.fromValue(r.filesize)).unsigned=!0:typeof r.filesize=="string"?n.filesize=parseInt(r.filesize,10):typeof r.filesize=="number"?n.filesize=r.filesize:typeof r.filesize=="object"&&(n.filesize=new $util.LongBits(r.filesize.low>>>0,r.filesize.high>>>0).toNumber(!0))),r.blocksizes){if(!Array.isArray(r.blocksizes))throw TypeError(".Data.blocksizes: array expected");n.blocksizes=[];for(var o=0;o<r.blocksizes.length;++o)$util.Long?(n.blocksizes[o]=$util.Long.fromValue(r.blocksizes[o])).unsigned=!0:typeof r.blocksizes[o]=="string"?n.blocksizes[o]=parseInt(r.blocksizes[o],10):typeof r.blocksizes[o]=="number"?n.blocksizes[o]=r.blocksizes[o]:typeof r.blocksizes[o]=="object"&&(n.blocksizes[o]=new $util.LongBits(r.blocksizes[o].low>>>0,r.blocksizes[o].high>>>0).toNumber(!0))}if(r.hashType!=null&&($util.Long?(n.hashType=$util.Long.fromValue(r.hashType)).unsigned=!0:typeof r.hashType=="string"?n.hashType=parseInt(r.hashType,10):typeof r.hashType=="number"?n.hashType=r.hashType:typeof r.hashType=="object"&&(n.hashType=new $util.LongBits(r.hashType.low>>>0,r.hashType.high>>>0).toNumber(!0))),r.fanout!=null&&($util.Long?(n.fanout=$util.Long.fromValue(r.fanout)).unsigned=!0:typeof r.fanout=="string"?n.fanout=parseInt(r.fanout,10):typeof r.fanout=="number"?n.fanout=r.fanout:typeof r.fanout=="object"&&(n.fanout=new $util.LongBits(r.fanout.low>>>0,r.fanout.high>>>0).toNumber(!0))),r.mode!=null&&(n.mode=r.mode>>>0),r.mtime!=null){if(typeof r.mtime!="object")throw TypeError(".Data.mtime: object expected");n.mtime=$root.UnixTime.fromObject(r.mtime)}return n},t.toObject=function(r,n){n||(n={});var o={};if((n.arrays||n.defaults)&&(o.blocksizes=[]),n.defaults){if(o.Type=n.enums===String?"Raw":0,n.bytes===String?o.Data="":(o.Data=[],n.bytes!==Array&&(o.Data=$util.newBuffer(o.Data))),$util.Long){var s=new $util.Long(0,0,!0);o.filesize=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else o.filesize=n.longs===String?"0":0;if($util.Long){var s=new $util.Long(0,0,!0);o.hashType=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else o.hashType=n.longs===String?"0":0;if($util.Long){var s=new $util.Long(0,0,!0);o.fanout=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else o.fanout=n.longs===String?"0":0;o.mode=0,o.mtime=null}if(r.Type!=null&&r.hasOwnProperty("Type")&&(o.Type=n.enums===String?$root.Data.DataType[r.Type]:r.Type),r.Data!=null&&r.hasOwnProperty("Data")&&(o.Data=n.bytes===String?$util.base64.encode(r.Data,0,r.Data.length):n.bytes===Array?Array.prototype.slice.call(r.Data):r.Data),r.filesize!=null&&r.hasOwnProperty("filesize")&&(typeof r.filesize=="number"?o.filesize=n.longs===String?String(r.filesize):r.filesize:o.filesize=n.longs===String?$util.Long.prototype.toString.call(r.filesize):n.longs===Number?new $util.LongBits(r.filesize.low>>>0,r.filesize.high>>>0).toNumber(!0):r.filesize),r.blocksizes&&r.blocksizes.length){o.blocksizes=[];for(var a=0;a<r.blocksizes.length;++a)typeof r.blocksizes[a]=="number"?o.blocksizes[a]=n.longs===String?String(r.blocksizes[a]):r.blocksizes[a]:o.blocksizes[a]=n.longs===String?$util.Long.prototype.toString.call(r.blocksizes[a]):n.longs===Number?new $util.LongBits(r.blocksizes[a].low>>>0,r.blocksizes[a].high>>>0).toNumber(!0):r.blocksizes[a]}return r.hashType!=null&&r.hasOwnProperty("hashType")&&(typeof r.hashType=="number"?o.hashType=n.longs===String?String(r.hashType):r.hashType:o.hashType=n.longs===String?$util.Long.prototype.toString.call(r.hashType):n.longs===Number?new $util.LongBits(r.hashType.low>>>0,r.hashType.high>>>0).toNumber(!0):r.hashType),r.fanout!=null&&r.hasOwnProperty("fanout")&&(typeof r.fanout=="number"?o.fanout=n.longs===String?String(r.fanout):r.fanout:o.fanout=n.longs===String?$util.Long.prototype.toString.call(r.fanout):n.longs===Number?new $util.LongBits(r.fanout.low>>>0,r.fanout.high>>>0).toNumber(!0):r.fanout),r.mode!=null&&r.hasOwnProperty("mode")&&(o.mode=r.mode),r.mtime!=null&&r.hasOwnProperty("mtime")&&(o.mtime=$root.UnixTime.toObject(r.mtime,n)),o},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t.DataType=function(){const e={},r=Object.create(e);return r[e[0]="Raw"]=0,r[e[1]="Directory"]=1,r[e[2]="File"]=2,r[e[3]="Metadata"]=3,r[e[4]="Symlink"]=4,r[e[5]="HAMTShard"]=5,r}(),t})();$root.UnixTime=(()=>{function t(e){if(e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.Seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,t.prototype.FractionalNanoseconds=0,t.encode=function(r,n){return n||(n=$Writer.create()),n.uint32(8).int64(r.Seconds),r.FractionalNanoseconds!=null&&Object.hasOwnProperty.call(r,"FractionalNanoseconds")&&n.uint32(21).fixed32(r.FractionalNanoseconds),n},t.decode=function(r,n){r instanceof $Reader||(r=$Reader.create(r));for(var o=n===void 0?r.len:r.pos+n,s=new $root.UnixTime;r.pos<o;){var a=r.uint32();switch(a>>>3){case 1:s.Seconds=r.int64();break;case 2:s.FractionalNanoseconds=r.fixed32();break;default:r.skipType(a&7);break}}if(!s.hasOwnProperty("Seconds"))throw $util.ProtocolError("missing required 'Seconds'",{instance:s});return s},t.fromObject=function(r){if(r instanceof $root.UnixTime)return r;var n=new $root.UnixTime;return r.Seconds!=null&&($util.Long?(n.Seconds=$util.Long.fromValue(r.Seconds)).unsigned=!1:typeof r.Seconds=="string"?n.Seconds=parseInt(r.Seconds,10):typeof r.Seconds=="number"?n.Seconds=r.Seconds:typeof r.Seconds=="object"&&(n.Seconds=new $util.LongBits(r.Seconds.low>>>0,r.Seconds.high>>>0).toNumber())),r.FractionalNanoseconds!=null&&(n.FractionalNanoseconds=r.FractionalNanoseconds>>>0),n},t.toObject=function(r,n){n||(n={});var o={};if(n.defaults){if($util.Long){var s=new $util.Long(0,0,!1);o.Seconds=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else o.Seconds=n.longs===String?"0":0;o.FractionalNanoseconds=0}return r.Seconds!=null&&r.hasOwnProperty("Seconds")&&(typeof r.Seconds=="number"?o.Seconds=n.longs===String?String(r.Seconds):r.Seconds:o.Seconds=n.longs===String?$util.Long.prototype.toString.call(r.Seconds):n.longs===Number?new $util.LongBits(r.Seconds.low>>>0,r.Seconds.high>>>0).toNumber():r.Seconds),r.FractionalNanoseconds!=null&&r.hasOwnProperty("FractionalNanoseconds")&&(o.FractionalNanoseconds=r.FractionalNanoseconds),o},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t})();$root.Metadata=(()=>{function t(e){if(e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.MimeType="",t.encode=function(r,n){return n||(n=$Writer.create()),r.MimeType!=null&&Object.hasOwnProperty.call(r,"MimeType")&&n.uint32(10).string(r.MimeType),n},t.decode=function(r,n){r instanceof $Reader||(r=$Reader.create(r));for(var o=n===void 0?r.len:r.pos+n,s=new $root.Metadata;r.pos<o;){var a=r.uint32();switch(a>>>3){case 1:s.MimeType=r.string();break;default:r.skipType(a&7);break}}return s},t.fromObject=function(r){if(r instanceof $root.Metadata)return r;var n=new $root.Metadata;return r.MimeType!=null&&(n.MimeType=String(r.MimeType)),n},t.toObject=function(r,n){n||(n={});var o={};return n.defaults&&(o.MimeType=""),r.MimeType!=null&&r.hasOwnProperty("MimeType")&&(o.MimeType=r.MimeType),o},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t})();function parseMode(t){if(t!=null)return typeof t=="number"?t&4095:(t=t.toString(),t.substring(0,1)==="0"?parseInt(t,8)&4095:parseInt(t,10)&4095)}function parseMtime(t){if(t==null)return;let e;if(t.secs!=null&&(e={secs:t.secs,nsecs:t.nsecs}),t.Seconds!=null&&(e={secs:t.Seconds,nsecs:t.FractionalNanoseconds}),Array.isArray(t)&&(e={secs:t[0],nsecs:t[1]}),t instanceof Date){const r=t.getTime(),n=Math.floor(r/1e3);e={secs:n,nsecs:(r-n*1e3)*1e3}}if(Object.prototype.hasOwnProperty.call(e,"secs")){if(e!=null&&e.nsecs!=null&&(e.nsecs<0||e.nsecs>999999999))throw errCode$1(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return e}}async function*normaliseCandidateMultiple(t,e){if(typeof t=="string"||t instanceof String||isBytes(t)||isBlob(t)||t._readableState)throw errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(isReadableStream(t)&&(t=browserReadableStreamToIt(t)),Symbol.iterator in t||Symbol.asyncIterator in t){const r=peekableIterator(t),{value:n,done:o}=await r.peek();if(o){yield*[];return}if(r.push(n),Number.isInteger(n))throw errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(n._readableState){yield*map(r,s=>toFileObject$1({content:s},e));return}if(isBytes(n)){yield toFileObject$1({content:r},e);return}if(isFileObject(n)||n[Symbol.iterator]||n[Symbol.asyncIterator]||isReadableStream(n)||isBlob(n)){yield*map(r,s=>toFileObject$1(s,e));return}}throw isFileObject(t)?errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT"):errCode$1(new Error("Unexpected input: "+typeof t),"ERR_UNEXPECTED_INPUT")}async function toFileObject$1(t,e){const{path:r,mode:n,mtime:o,content:s}=t,a={path:r||"",mode:parseMode(n),mtime:parseMtime(o)};return s?a.content=await e(s):r||(a.content=await e(t)),a}function normaliseInput$2(t){return normaliseCandidateMultiple(t,normaliseContent$1)}function modeToString(t){if(t!=null)return typeof t=="string"?t:t.toString(8).padStart(4,"0")}async function multipartRequest(t,e,r={}){const n=[],o=new FormData;let s=0,a=0;for await(const{content:i,path:c,mode:d,mtime:l}of normaliseInput$2(t)){let f="";const p=i?"file":"dir";s>0&&(f=`-${s}`);let v=p+f;const u=[];if(d!=null&&u.push(`mode=${modeToString(d)}`),l!=null){const{secs:h,nsecs:S}=l;u.push(`mtime=${h}`),S!=null&&u.push(`mtime-nsecs=${S}`)}if(u.length&&(v=`${v}?${u.join("&")}`),i){o.set(v,i,c!=null?encodeURIComponent(c):void 0);const h=a+i.size;n.push({name:c,start:a,end:h}),a=h}else if(c!=null)o.set(v,new File([""],encodeURIComponent(c),{type:"application/x-directory"}));else throw new Error("path or content or both must be set");s++}return{total:a,parts:n,headers:r,body:o}}function filter(t){return t.filter(Boolean)}function abortSignal(...t){return anySignal_2(filter(t))}const createPut$3=configure(t=>{async function e(r,n={}){const o=new AbortController,s=abortSignal(o.signal,n.signal);let a;try{a=await(await t.post("block/put",{signal:s,searchParams:toUrlSearchParams(n),...await multipartRequest([r],o,n.headers)})).json()}catch(i){if(n.format==="dag-pb")return e(r,{...n,format:"protobuf"});if(n.format==="dag-cbor")return e(r,{...n,format:"cbor"});throw i}return CID$2.parse(a.Key)}return e}),createRm$6=configure(t=>{async function*e(r,n={}){Array.isArray(r)||(r=[r]);const o=await t.post("block/rm",{signal:n.signal,searchParams:toUrlSearchParams({arg:r.map(s=>s.toString()),"stream-channels":!0,...n}),headers:n.headers});for await(const s of o.ndjson())yield toCoreInterface$3(s)}return e});function toCoreInterface$3(t){const e={cid:CID$2.parse(t.Hash)};return t.Error&&(e.error=new Error(t.Error)),e}const createStat$3=configure(t=>{async function e(r,n={}){const s=await(await t.post("block/stat",{signal:n.signal,searchParams:toUrlSearchParams({arg:r.toString(),...n}),headers:n.headers})).json();return{cid:CID$2.parse(s.Key),size:s.Size}}return e});function createBlock(t){return{get:createGet$5(t),put:createPut$3(t),rm:createRm$6(t),stat:createStat$3(t)}}const createAdd$4=configure(t=>{async function e(r,n={}){const o=await t.post("bootstrap/add",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers}),{Peers:s}=await o.json();return{Peers:s.map(a=>multiaddr$1(a))}}return e}),createClear=configure(t=>{async function e(r={}){const n=await t.post("bootstrap/rm",{signal:r.signal,searchParams:toUrlSearchParams({...r,all:!0}),headers:r.headers}),{Peers:o}=await n.json();return{Peers:o.map(s=>multiaddr$1(s))}}return e}),createList$2=configure(t=>{async function e(r={}){const n=await t.post("bootstrap/list",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers}),{Peers:o}=await n.json();return{Peers:o.map(s=>multiaddr$1(s))}}return e}),createReset=configure(t=>{async function e(r={}){const n=await t.post("bootstrap/add",{signal:r.signal,searchParams:toUrlSearchParams({...r,default:!0}),headers:r.headers}),{Peers:o}=await n.json();return{Peers:o.map(s=>multiaddr$1(s))}}return e}),createRm$5=configure(t=>{async function e(r,n={}){const o=await t.post("bootstrap/rm",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers}),{Peers:s}=await o.json();return{Peers:s.map(a=>multiaddr$1(a))}}return e});function createBootstrap(t){return{add:createAdd$4(t),clear:createClear(t),list:createList$2(t),reset:createReset(t),rm:createRm$5(t)}}const createApply=configure(t=>{async function e(r,n={}){const s=await(await t.post("config/profile/apply",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers})).json();return{original:s.OldCfg,updated:s.NewCfg}}return e});function objectToCamel(t){if(t==null)return t;const e=/^[A-Z]+$/,r={};return Object.keys(t).reduce((n,o)=>(e.test(o)?n[o.toLowerCase()]=t[o]:e.test(o[0])?n[o[0].toLowerCase()+o.slice(1)]=t[o]:n[o]=t[o],n),r)}const createList$1=configure(t=>{async function e(r={}){return(await(await t.post("config/profile/list",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json()).map(s=>objectToCamel(s))}return e});function createProfiles(t){return{apply:createApply(t),list:createList$1(t)}}const createGet$4=configure(t=>async(r,n={})=>{if(!r)throw new Error("key argument is required");return(await(await t.post("config",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers})).json()).Value}),createGetAll=configure(t=>async(r={})=>await(await t.post("config/show",{signal:r.signal,searchParams:toUrlSearchParams({...r}),headers:r.headers})).json()),createReplace=configure(t=>async(r,n={})=>{const o=new AbortController,s=abortSignal(o.signal,n.signal);await(await t.post("config/replace",{signal:s,searchParams:toUrlSearchParams(n),...await multipartRequest([fromString$3(JSON.stringify(r))],o,n.headers)})).text()}),createSet=configure(t=>async(r,n,o={})=>{if(typeof r!="string")throw new Error("Invalid key type");const s={...o,...encodeParam(r,n)};await(await t.post("config",{signal:o.signal,searchParams:toUrlSearchParams(s),headers:o.headers})).text()}),encodeParam=(t,e)=>{switch(typeof e){case"boolean":return{arg:[t,e.toString()],bool:!0};case"string":return{arg:[t,e]};default:return{arg:[t,JSON.stringify(e)],json:!0}}};function createConfig(t){return{getAll:createGetAll(t),get:createGet$4(t),set:createSet(t),replace:createReplace(t),profiles:createProfiles(t)}}const createExport$1=configure(t=>{async function*e(r,n={}){yield*(await t.post("dag/export",{signal:n.signal,searchParams:toUrlSearchParams({arg:r.toString()}),headers:n.headers})).iterator()}return e});async function*resolve(t,e,r,n,o){const s=async d=>{const l=await r.getCodec(d.code),f=await n(d,o);return l.decode(f)},a=e.split("/").filter(Boolean);let i=await s(t),c=t;for(;a.length;){const d=a.shift();if(!d)throw errCode$1(new Error(`Could not resolve path "${e}"`),"ERR_INVALID_PATH");if(Object.prototype.hasOwnProperty.call(i,d))i=i[d],yield{value:i,remainderPath:a.join("/")};else throw errCode$1(new Error(`no link named "${d}" under ${c}`),"ERR_NO_LINK");const l=CID$2.asCID(i);l&&(c=l,i=await s(i))}yield{value:i,remainderPath:""}}async function first(t){for await(const e of t)return e}async function last(t){let e;for await(const r of t)e=r;return e}const createGet$3=(t,e)=>configure((n,o)=>{const s=createGet$5(o);return async(i,c={})=>{if(c.path){const v=c.localResolve?await first(resolve(i,c.path,t,s,c)):await last(resolve(i,c.path,t,s,c));if(!v)throw errCode$1(new Error("Not found"),"ERR_NOT_FOUND");return v}const d=await t.getCodec(i.code),l=await s(i,c);return{value:d.decode(l),remainderPath:""}}})(e),createImport$1=configure(t=>{async function*e(r,n={}){const o=new AbortController,s=abortSignal(o.signal,n.signal),{headers:a,body:i}=await multipartRequest(r,o,n.headers),c=await t.post("dag/import",{signal:s,headers:a,body:i,searchParams:toUrlSearchParams({"pin-roots":n.pinRoots})});for await(const{Root:d}of c.ndjson())if(d!==void 0){const{Cid:{"/":l},PinErrorMsg:f}=d;yield{root:{cid:CID$2.parse(l),pinErrorMsg:f}}}}return e}),createPut$2=(t,e)=>configure(n=>async(s,a={})=>{const i={storeCodec:"dag-cbor",hashAlg:"sha2-256",...a};let c;if(i.inputCodec){if(!(s instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");c=s}else c=(await t.getCodec(i.storeCodec)).encode(s),i.inputCodec=i.storeCodec;const d=new AbortController,l=abortSignal(d.signal,i.signal),p=await(await n.post("dag/put",{timeout:i.timeout,signal:l,searchParams:toUrlSearchParams(i),...await multipartRequest([c],d,i.headers)})).json();return CID$2.parse(p.Cid["/"])})(e),createResolve$2=configure(t=>async(r,n={})=>{const s=await(await t.post("dag/resolve",{signal:n.signal,searchParams:toUrlSearchParams({arg:`${r}${n.path?`/${n.path}`.replace(/\/[/]+/g,"/"):""}`,...n}),headers:n.headers})).json();return{cid:CID$2.parse(s.Cid["/"]),remainderPath:s.RemPath}});function createDag(t,e){return{export:createExport$1(e),get:createGet$3(t,e),import:createImport$1(e),put:createPut$2(t,e),resolve:createResolve$2(e)}}const SendingQuery=0,PeerResponse=1,FinalPeer=2,QueryError=3,Provider=4,Value=5,AddingPeer=6,DialingPeer=7,mapEvent=t=>{if(t.Type===SendingQuery)return{name:"SENDING_QUERY",type:t.Type};if(t.Type===PeerResponse)return{from:peerIdFromString(t.ID),name:"PEER_RESPONSE",type:t.Type,messageType:0,messageName:"PUT_VALUE",closer:(t.Responses||[]).map(({ID:e,Addrs:r})=>({id:peerIdFromString(e),multiaddrs:r.map(n=>multiaddr$1(n)),protocols:[]})),providers:(t.Responses||[]).map(({ID:e,Addrs:r})=>({id:peerIdFromString(e),multiaddrs:r.map(n=>multiaddr$1(n)),protocols:[]}))};if(t.Type===FinalPeer){let e={id:t.ID??peerIdFromString(t.ID),multiaddrs:[],protocols:[]};return t.Responses&&t.Responses.length&&(e={id:peerIdFromString(t.Responses[0].ID),multiaddrs:t.Responses[0].Addrs.map(r=>multiaddr$1(r)),protocols:[]}),{name:"FINAL_PEER",type:t.Type,peer:e}}if(t.Type===QueryError)return{name:"QUERY_ERROR",type:t.Type,error:new Error(t.Extra)};if(t.Type===Provider)return{name:"PROVIDER",type:t.Type,providers:t.Responses.map(({ID:e,Addrs:r})=>({id:peerIdFromString(e),multiaddrs:r.map(n=>multiaddr$1(n)),protocols:[]}))};if(t.Type===Value)return{name:"VALUE",type:t.Type,value:fromString$3(t.Extra,"base64pad")};if(t.Type===AddingPeer){const e=t.Responses.map(({ID:r})=>peerIdFromString(r));if(!e.length)throw new Error("No peer found");return{name:"ADDING_PEER",type:t.Type,peer:e[0]}}if(t.Type===DialingPeer)return{name:"DIALING_PEER",type:t.Type,peer:peerIdFromString(t.ID)};throw new Error("Unknown DHT event type")},createFindPeer=configure(t=>{async function*e(r,n={}){const o=await t.post("dht/findpeer",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers});for await(const s of o.ndjson())yield mapEvent(s)}return e}),createFindProvs=configure(t=>{async function*e(r,n={}){const o=await t.post("dht/findprovs",{signal:n.signal,searchParams:toUrlSearchParams({arg:r.toString(),...n}),headers:n.headers});for await(const s of o.ndjson())yield mapEvent(s)}return e}),createGet$2=configure(t=>{async function*e(r,n={}){const o=await t.post("dht/get",{signal:n.signal,searchParams:toUrlSearchParams({arg:r instanceof Uint8Array?toString$4(r):r.toString(),...n}),headers:n.headers});for await(const s of o.ndjson())yield mapEvent(s)}return e}),createProvide=configure(t=>{async function*e(r,n={recursive:!1}){const o=Array.isArray(r)?r:[r],s=await t.post("dht/provide",{signal:n.signal,searchParams:toUrlSearchParams({arg:o.map(a=>a.toString()),...n}),headers:n.headers});for await(const a of s.ndjson())yield mapEvent(a)}return e}),createPut$1=configure(t=>{async function*e(r,n,o={}){const s=new AbortController,a=abortSignal(s.signal,o.signal),i=await t.post("dht/put",{signal:a,searchParams:toUrlSearchParams({arg:r instanceof Uint8Array?toString$4(r):r.toString(),...o}),...await multipartRequest([n],s,o.headers)});for await(const c of i.ndjson())yield mapEvent(c)}return e}),createQuery=configure(t=>{async function*e(r,n={}){const o=await t.post("dht/query",{signal:n.signal,searchParams:toUrlSearchParams({arg:r.toString(),...n}),headers:n.headers});for await(const s of o.ndjson())yield mapEvent(s)}return e});function createDht(t){return{findPeer:createFindPeer(t),findProvs:createFindProvs(t),get:createGet$2(t),provide:createProvide(t),put:createPut$1(t),query:createQuery(t)}}const createCmds=configure(t=>{async function e(r={}){return(await t.post("diag/cmds",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json()}return e}),createNet=configure(t=>{async function e(r={}){return(await t.post("diag/net",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json()}return e}),createSys=configure(t=>{async function e(r={}){return(await t.post("diag/sys",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json()}return e});function createDiag(t){return{cmds:createCmds(t),net:createNet(t),sys:createSys(t)}}const createChmod=configure(t=>{async function e(r,n,o={}){await(await t.post("files/chmod",{signal:o.signal,searchParams:toUrlSearchParams({arg:r,mode:n,...o}),headers:o.headers})).text()}return e}),createCp=configure(t=>{async function e(r,n,o={}){const s=Array.isArray(r)?r:[r];await(await t.post("files/cp",{signal:o.signal,searchParams:toUrlSearchParams({arg:s.concat(n).map(i=>CID$2.asCID(i)?`/ipfs/${i}`:i),...o}),headers:o.headers})).text()}return e}),createFlush=configure(t=>{async function e(r,n={}){if(!r||typeof r!="string")throw new Error("ipfs.files.flush requires a path");const s=await(await t.post("files/flush",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers})).json();return CID$2.parse(s.Cid)}return e});function objectToCamelWithMetadata(t){const e=objectToCamel(t);return Object.prototype.hasOwnProperty.call(e,"mode")&&(e.mode=parseInt(e.mode,8)),Object.prototype.hasOwnProperty.call(e,"mtime")&&(e.mtime={secs:e.mtime,nsecs:e.mtimeNsecs||0},delete e.mtimeNsecs),e}const createLs$6=configure(t=>{async function*e(r,n={}){if(!r)throw new Error("ipfs.files.ls requires a path");const o=await t.post("files/ls",{signal:n.signal,searchParams:toUrlSearchParams({arg:CID$2.asCID(r)?`/ipfs/${r}`:r,long:!0,...n,stream:!0}),headers:n.headers});for await(const s of o.ndjson())if("Entries"in s)for(const a of s.Entries||[])yield toCoreInterface$2(objectToCamelWithMetadata(a));else yield toCoreInterface$2(objectToCamelWithMetadata(s))}return e});function toCoreInterface$2(t){return t.hash&&(t.cid=CID$2.parse(t.hash)),delete t.hash,t.type=t.type===1?"directory":"file",t}const createMkdir=configure(t=>{async function e(r,n={}){await(await t.post("files/mkdir",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers})).text()}return e}),createMv=configure(t=>{async function e(r,n,o={}){Array.isArray(r)||(r=[r]),await(await t.post("files/mv",{signal:o.signal,searchParams:toUrlSearchParams({arg:r.concat(n),...o}),headers:o.headers})).text()}return e});var source=t=>{if(t[Symbol.asyncIterator])return t;if(t.getReader)return async function*(){const e=t.getReader();try{for(;;){const{done:r,value:n}=await e.read();if(r)return;yield n}}finally{e.releaseLock()}}();throw new Error("unknown stream")};const toIterable=getDefaultExportFromCjs(source),createRead=configure(t=>{async function*e(r,n={}){const o=await t.post("files/read",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,count:n.length,...n}),headers:n.headers});yield*toIterable(o.body)}return e}),createRm$4=configure(t=>{async function e(r,n={}){const o=await t.post("files/rm",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers}),s=await o.text();if(s!==""){const a=new HTTP$1.HTTPError(o);throw a.message=s,a}}return e}),createStat$2=configure(t=>{async function e(r,n={}){const s=await(await t.post("files/stat",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers})).json();return s.WithLocality=s.WithLocality||!1,toCoreInterface$1(objectToCamelWithMetadata(s))}return e});function toCoreInterface$1(t){return t.cid=CID$2.parse(t.hash),delete t.hash,t}const createTouch=configure(t=>{async function e(r,n={}){await(await t.post("files/touch",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers})).text()}return e}),createWrite=configure(t=>{async function e(r,n,o={}){const s=new AbortController,a=abortSignal(s.signal,o.signal);await(await t.post("files/write",{signal:a,searchParams:toUrlSearchParams({arg:r,streamChannels:!0,count:o.length,...o}),...await multipartRequest([{content:n,path:"arg",mode:modeToString$1(o.mode),mtime:parseMtime$1(o.mtime)}],s,o.headers)})).text()}return e});function createFiles(t){return{chmod:createChmod(t),cp:createCp(t),flush:createFlush(t),ls:createLs$6(t),mkdir:createMkdir(t),mv:createMv(t),read:createRead(t),rm:createRm$4(t),stat:createStat$2(t),touch:createTouch(t),write:createWrite(t)}}const createExport=configure(t=>async(r,n,o={})=>{throw errCode$1(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")}),createGen=configure(t=>{async function e(r,n={type:"Ed25519"}){const s=await(await t.post("key/gen",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers})).json();return objectToCamel(s)}return e}),createImport=configure(t=>{async function e(r,n,o,s={}){const i=await(await t.post("key/import",{signal:s.signal,searchParams:toUrlSearchParams({arg:r,pem:n,password:o,...s}),headers:s.headers})).json();return objectToCamel(i)}return e}),createInfo=configure(t=>async(r,n={})=>{throw errCode$1(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")}),createList=configure(t=>{async function e(r={}){return((await(await t.post("key/list",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json()).Keys||[]).map(s=>objectToCamel(s))}return e}),createRename=configure(t=>{async function e(r,n,o={}){const s=await t.post("key/rename",{signal:o.signal,searchParams:toUrlSearchParams({arg:[r,n],...o}),headers:o.headers});return objectToCamel(await s.json())}return e}),createRm$3=configure(t=>{async function e(r,n={}){const s=await(await t.post("key/rm",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers})).json();return objectToCamel(s.Keys[0])}return e});function createKey(t){return{export:createExport(t),gen:createGen(t),import:createImport(t),info:createInfo(t),list:createList(t),rename:createRename(t),rm:createRm$3(t)}}const createLevel=configure(t=>{async function e(r,n,o={}){const s=await t.post("log/level",{signal:o.signal,searchParams:toUrlSearchParams({arg:[r,n],...o}),headers:o.headers});return objectToCamel(await s.json())}return e}),createLs$5=configure(t=>{async function e(r={}){return(await(await t.post("log/ls",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json()).Strings}return e}),createTail=configure(t=>{async function*e(r={}){yield*(await t.post("log/tail",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).ndjson()}return e});function createLog(t){return{level:createLevel(t),ls:createLs$5(t),tail:createTail(t)}}const createPublish$1=configure(t=>{async function e(r,n={}){const o=await t.post("name/publish",{signal:n.signal,searchParams:toUrlSearchParams({arg:`${r}`,...n}),headers:n.headers});return objectToCamel(await o.json())}return e}),createResolve$1=configure(t=>{async function*e(r,n={}){const o=await t.post("name/resolve",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,stream:!0,...n}),headers:n.headers});for await(const s of o.ndjson())yield s.Path}return e}),createCancel=configure(t=>{async function e(r,n={}){const o=await t.post("name/pubsub/cancel",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers});return objectToCamel(await o.json())}return e}),createState=configure(t=>{async function e(r={}){const n=await t.post("name/pubsub/state",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers});return objectToCamel(await n.json())}return e}),createSubs=configure(t=>{async function e(r={}){return(await(await t.post("name/pubsub/subs",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json()).Strings||[]}return e});function createPubsub$1(t){return{cancel:createCancel(t),state:createState(t),subs:createSubs(t)}}function createName(t){return{publish:createPublish$1(t),resolve:createResolve$1(t),pubsub:createPubsub$1(t)}}const createData=configure(t=>{async function e(r,n={}){const s=await(await t.post("object/data",{signal:n.signal,searchParams:toUrlSearchParams({arg:`${r instanceof Uint8Array?CID$2.decode(r):r}`,...n}),headers:n.headers})).arrayBuffer();return new Uint8Array(s,0,s.byteLength)}return e}),createGet$1=configure(t=>{async function e(r,n={}){const s=await(await t.post("object/get",{signal:n.signal,searchParams:toUrlSearchParams({arg:`${r instanceof Uint8Array?CID$2.decode(r):r}`,dataEncoding:"base64",...n}),headers:n.headers})).json();return{Data:fromString$3(s.Data,"base64pad"),Links:(s.Links||[]).map(a=>({Name:a.Name,Hash:CID$2.parse(a.Hash),Tsize:a.Size}))}}return e}),createLinks=configure(t=>{async function e(r,n={}){return((await(await t.post("object/links",{signal:n.signal,searchParams:toUrlSearchParams({arg:`${r instanceof Uint8Array?CID$2.decode(r):r}`,...n}),headers:n.headers})).json()).Links||[]).map(a=>({Name:a.Name,Tsize:a.Size,Hash:CID$2.parse(a.Hash)}))}return e}),createNew=configure(t=>{async function e(r={}){const n=await t.post("object/new",{signal:r.signal,searchParams:toUrlSearchParams({arg:r.template,...r}),headers:r.headers}),{Hash:o}=await n.json();return CID$2.parse(o)}return e}),createPut=(t,e)=>configure(n=>{const o=createPut$2(t,e);async function s(a,i={}){return o(a,{...i,storeCodec:"dag-pb",hashAlg:"sha2-256",version:1})}return s})(e),createStat$1=configure(t=>{async function e(r,n={}){const s=await(await t.post("object/stat",{signal:n.signal,searchParams:toUrlSearchParams({arg:`${r}`,...n}),headers:n.headers})).json();return{...s,Hash:CID$2.parse(s.Hash)}}return e}),createAddLink=configure(t=>{async function e(r,n,o={}){const s=await t.post("object/patch/add-link",{signal:o.signal,searchParams:toUrlSearchParams({arg:[`${r}`,n.Name||n.name||"",(n.Hash||n.cid||"").toString()||null],...o}),headers:o.headers}),{Hash:a}=await s.json();return CID$2.parse(a)}return e}),createAppendData=configure(t=>{async function e(r,n,o={}){const s=new AbortController,a=abortSignal(s.signal,o.signal),i=await t.post("object/patch/append-data",{signal:a,searchParams:toUrlSearchParams({arg:`${r}`,...o}),...await multipartRequest([n],s,o.headers)}),{Hash:c}=await i.json();return CID$2.parse(c)}return e}),createRmLink=configure(t=>{async function e(r,n,o={}){const s=await t.post("object/patch/rm-link",{signal:o.signal,searchParams:toUrlSearchParams({arg:[`${r}`,n.Name||n.name||null],...o}),headers:o.headers}),{Hash:a}=await s.json();return CID$2.parse(a)}return e}),createSetData=configure(t=>{async function e(r,n,o={}){const s=new AbortController,a=abortSignal(s.signal,o.signal),i=await t.post("object/patch/set-data",{signal:a,searchParams:toUrlSearchParams({arg:[`${r}`],...o}),...await multipartRequest([n],s,o.headers)}),{Hash:c}=await i.json();return CID$2.parse(c)}return e});function createPatch(t){return{addLink:createAddLink(t),appendData:createAppendData(t),rmLink:createRmLink(t),setData:createSetData(t)}}function createObject(t,e){return{data:createData(e),get:createGet$1(e),links:createLinks(e),new:createNew(e),put:createPut(t,e),stat:createStat$1(e),patch:createPatch(e)}}async function*normaliseInput$1(t){if(t==null)throw errCode$1(new Error(`Unexpected input: ${t}`),"ERR_UNEXPECTED_INPUT");const e=CID$2.asCID(t);if(e){yield toPin$1({cid:e});return}if(t instanceof String||typeof t=="string"){yield toPin$1({path:t});return}if(t.cid!=null||t.path!=null)return yield toPin$1(t);if(Symbol.iterator in t){const r=t[Symbol.iterator](),n=r.next();if(n.done)return r;if(CID$2.asCID(n.value)||n.value instanceof String||typeof n.value=="string"){yield toPin$1({cid:n.value});for(const o of r)yield toPin$1({cid:o});return}if(n.value.cid!=null||n.value.path!=null){yield toPin$1(n.value);for(const o of r)yield toPin$1(o);return}throw errCode$1(new Error("Unexpected input: "+typeof t),"ERR_UNEXPECTED_INPUT")}if(Symbol.asyncIterator in t){const r=t[Symbol.asyncIterator](),n=await r.next();if(n.done)return r;if(CID$2.asCID(n.value)||n.value instanceof String||typeof n.value=="string"){yield toPin$1({cid:n.value});for await(const o of r)yield toPin$1({cid:o});return}if(n.value.cid!=null||n.value.path!=null){yield toPin$1(n.value);for await(const o of r)yield toPin$1(o);return}throw errCode$1(new Error("Unexpected input: "+typeof t),"ERR_UNEXPECTED_INPUT")}throw errCode$1(new Error("Unexpected input: "+typeof t),"ERR_UNEXPECTED_INPUT")}function toPin$1(t){const e=t.cid||`${t.path}`;if(!e)throw errCode$1(new Error("Unexpected input: Please path either a CID or an IPFS path"),"ERR_UNEXPECTED_INPUT");const r={path:e,recursive:t.recursive!==!1};return t.metadata!=null&&(r.metadata=t.metadata),r}const createAddAll$1=configure(t=>{async function*e(r,n={}){for await(const{path:o,recursive:s,metadata:a}of normaliseInput$1(r)){const i=await t.post("pin/add",{signal:n.signal,searchParams:toUrlSearchParams({...n,arg:o,recursive:s,metadata:a?JSON.stringify(a):void 0,stream:!0}),headers:n.headers});for await(const c of i.ndjson()){if(c.Pins){for(const d of c.Pins)yield CID$2.parse(d);continue}yield CID$2.parse(c)}}}return e});function createAdd$3(t){const e=createAddAll$1(t);return configure(()=>{async function r(n,o={}){return last(e([{path:n,...o}],o))}return r})(t)}function toPin(t,e,r){const n={type:t,cid:CID$2.parse(e)};return r&&(n.metadata=r),n}const createLs$4=configure(t=>{async function*e(r={}){let n=[];r.paths&&(n=Array.isArray(r.paths)?r.paths:[r.paths]);const o=await t.post("pin/ls",{signal:r.signal,searchParams:toUrlSearchParams({...r,arg:n.map(s=>`${s}`),stream:!0}),headers:r.headers});for await(const s of o.ndjson()){if(s.Keys){for(const a of Object.keys(s.Keys))yield toPin(s.Keys[a].Type,a,s.Keys[a].Metadata);return}yield toPin(s.Type,s.Cid,s.Metadata)}}return e}),createRmAll$1=configure(t=>{async function*e(r,n={}){for await(const{path:o,recursive:s}of normaliseInput$1(r)){const a=new URLSearchParams(n.searchParams);a.append("arg",`${o}`),s!=null&&a.set("recursive",String(s));const i=await t.post("pin/rm",{signal:n.signal,headers:n.headers,searchParams:toUrlSearchParams({...n,arg:`${o}`,recursive:s})});for await(const c of i.ndjson()){if(c.Pins){yield*c.Pins.map(d=>CID$2.parse(d));continue}yield CID$2.parse(c)}}}return e}),createRm$2=t=>{const e=createRmAll$1(t);return configure(()=>{async function r(n,o={}){return last(e([{path:n,...o}],o))}return r})(t)},decodePin=({Name:t,Status:e,Cid:r})=>({cid:CID$2.parse(r),name:t,status:e}),encodeService=t=>{if(typeof t=="string"&&t!=="")return t;throw new TypeError("service name must be passed")},encodeCID=t=>{if(CID$2.asCID(t))return t.toString();throw new TypeError(`CID instance expected instead of ${typeof t}`)},encodeQuery=({service:t,cid:e,name:r,status:n,all:o})=>{const s=toUrlSearchParams({service:encodeService(t),name:r,force:o?!0:void 0});if(e)for(const a of e)s.append("cid",encodeCID(a));if(n)for(const a of n)s.append("status",a);return s},encodeAddParams=({cid:t,service:e,background:r,name:n,origins:o})=>{const s=toUrlSearchParams({arg:encodeCID(t),service:encodeService(e),name:n,background:r?!0:void 0});if(o)for(const a of o)s.append("origin",a.toString());return s};function createAdd$2(t){async function e(r,{timeout:n,signal:o,headers:s,...a}){const i=await t.post("pin/remote/add",{timeout:n,signal:o,headers:s,searchParams:encodeAddParams({cid:r,...a})});return decodePin(await i.json())}return e}function createLs$3(t){async function*e({timeout:r,signal:n,headers:o,...s}){const a=await t.post("pin/remote/ls",{timeout:r,signal:n,headers:o,searchParams:encodeQuery(s)});for await(const i of a.ndjson())yield decodePin(i)}return e}function createRm$1(t){async function e({timeout:r,signal:n,headers:o,...s}){await t.post("pin/remote/rm",{timeout:r,signal:n,headers:o,searchParams:encodeQuery({...s,all:!1})})}return e}function createRmAll(t){async function e({timeout:r,signal:n,headers:o,...s}){await t.post("pin/remote/rm",{timeout:r,signal:n,headers:o,searchParams:encodeQuery({...s,all:!0})})}return e}function encodeEndpoint(t){const e=String(t);if(e==="undefined")throw Error("endpoint is required");return e[e.length-1]==="/"?e.slice(0,-1):e}function decodeRemoteService(t){return{service:t.Service,endpoint:new URL(t.ApiEndpoint),...t.Stat&&{stat:decodeStat(t.Stat)}}}function decodeStat(t){switch(t.Status){case"valid":{const{Pinning:e,Pinned:r,Queued:n,Failed:o}=t.PinCount;return{status:"valid",pinCount:{queued:n,pinning:e,pinned:r,failed:o}}}case"invalid":return{status:"invalid"};default:return{status:t.Status}}}function createAdd$1(t){async function e(r,n){const{endpoint:o,key:s,headers:a,timeout:i,signal:c}=n;await t.post("pin/remote/service/add",{timeout:i,signal:c,searchParams:toUrlSearchParams({arg:[r,encodeEndpoint(o),s]}),headers:a})}return e}function createLs$2(t){async function e(r={}){const{stat:n,headers:o,timeout:s,signal:a}=r,i=await t.post("pin/remote/service/ls",{timeout:s,signal:a,headers:o,searchParams:n===!0?toUrlSearchParams({stat:n}):void 0}),{RemoteServices:c}=await i.json();return c.map(decodeRemoteService)}return e}function createRm(t){async function e(r,n={}){await t.post("pin/remote/service/rm",{signal:n.signal,headers:n.headers,searchParams:toUrlSearchParams({arg:r})})}return e}function createService(t){const e=new Client(t);return{add:createAdd$1(e),ls:createLs$2(e),rm:createRm(e)}}function createRemote(t){const e=new Client(t);return{add:createAdd$2(e),ls:createLs$3(e),rm:createRm$1(e),rmAll:createRmAll(e),service:createService(t)}}function createPin(t){return{addAll:createAddAll$1(t),add:createAdd$3(t),ls:createLs$4(t),rmAll:createRmAll$1(t),rm:createRm$2(t),remote:createRemote(t)}}const rpcArrayToTextArray=t=>Array.isArray(t)?t.map(rpcToText):t,rpcToText=t=>toString$4(rpcToBytes(t)),rpcToBytes=t=>base64url$3.decode(t),rpcToBigInt=t=>BigInt(`0x${toString$4(base64url$3.decode(t),"base16")}`),textToUrlSafeRpc=t=>base64url$3.encode(fromString$3(t)),createLs$1=configure(t=>{async function e(r={}){const{Strings:n}=await(await t.post("pubsub/ls",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json();return rpcArrayToTextArray(n)||[]}return e}),createPeers$1=configure(t=>{async function e(r,n={}){const o=await t.post("pubsub/peers",{signal:n.signal,searchParams:toUrlSearchParams({arg:textToUrlSafeRpc(r),...n}),headers:n.headers}),{Strings:s}=await o.json();return s||[]}return e}),createPublish=configure(t=>{async function e(r,n,o={}){const s=toUrlSearchParams({arg:textToUrlSafeRpc(r),...o}),a=new AbortController,i=abortSignal(a.signal,o.signal);await(await t.post("pubsub/pub",{signal:i,searchParams:s,...await multipartRequest([n],a,o.headers)})).text()}return e}),log=logger("ipfs-http-client:pubsub:subscribe"),createSubscribe=(t,e)=>configure(r=>{async function n(o,s,a={}){a.signal=e.subscribe(o,s,a.signal);let i,c;const d=new Promise((f,p)=>{i=f,c=p}),l=setTimeout(()=>i(),1e3);return r.post("pubsub/sub",{signal:a.signal,searchParams:toUrlSearchParams({arg:textToUrlSafeRpc(o),...a}),headers:a.headers}).catch(f=>{e.unsubscribe(o,s),c(f)}).then(f=>{clearTimeout(l),f&&(readMessages(f,{onMessage:p=>{if(s){if(typeof s=="function"){s(p);return}typeof s.handleEvent=="function"&&s.handleEvent(p)}},onEnd:()=>e.unsubscribe(o,s),onError:a.onError}),i())}),d}return n})(t);async function readMessages(t,{onMessage:e,onEnd:r,onError:n}){n=n||log;try{for await(const o of t.ndjson())try{if(!o.from)continue;o.from!=null&&o.seqno!=null?e({type:"signed",from:peerIdFromString(o.from),data:rpcToBytes(o.data),sequenceNumber:rpcToBigInt(o.seqno),topic:rpcToText(o.topicIDs[0]),key:rpcToBytes(o.key??"u"),signature:rpcToBytes(o.signature??"u")}):e({type:"unsigned",data:rpcToBytes(o.data),topic:rpcToText(o.topicIDs[0])})}catch(s){s.message=`Failed to parse pubsub message: ${s.message}`,n(s,!1,o)}}catch(o){isAbortError(o)||n(o,!0)}finally{r()}}const isAbortError=t=>{switch(t.type){case"aborted":return!0;case"abort":return!0;default:return t.name==="AbortError"}},createUnsubscribe=(t,e)=>{async function r(n,o){e.unsubscribe(n,o)}return r};class SubscriptionTracker{constructor(){this._subs=new Map}subscribe(e,r,n){const o=this._subs.get(e)||[];if(o.find(a=>a.handler===r))throw new Error(`Already subscribed to ${e} with this handler`);const s=new AbortController;return this._subs.set(e,[{handler:r,controller:s}].concat(o)),n&&n.addEventListener("abort",()=>this.unsubscribe(e,r)),s.signal}unsubscribe(e,r){const n=this._subs.get(e)||[];let o;r?(this._subs.set(e,n.filter(s=>s.handler!==r)),o=n.filter(s=>s.handler===r)):(this._subs.set(e,[]),o=n),(this._subs.get(e)||[]).length||this._subs.delete(e),o.forEach(s=>s.controller.abort())}}function createPubsub(t){const e=new SubscriptionTracker;return{ls:createLs$1(t),peers:createPeers$1(t),publish:createPublish(t),subscribe:createSubscribe(t,e),unsubscribe:createUnsubscribe(t,e)}}const createLocal=configure(t=>{async function*e(r={}){yield*(await t.post("refs/local",{signal:r.signal,transform:objectToCamel,searchParams:toUrlSearchParams(r),headers:r.headers})).ndjson()}return e}),createRefs=configure((t,e)=>Object.assign(async function*(n,o={}){const s=Array.isArray(n)?n:[n];yield*(await t.post("refs",{signal:o.signal,searchParams:toUrlSearchParams({arg:s.map(i=>`${i instanceof Uint8Array?CID$2.decode(i):i}`),...o}),headers:o.headers,transform:objectToCamel})).ndjson()},{local:createLocal(e)})),createGc=configure(t=>{async function*e(r={}){yield*(await t.post("repo/gc",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers,transform:o=>({err:o.Error?new Error(o.Error):null,cid:(o.Key||{})["/"]?CID$2.parse(o.Key["/"]):null})})).ndjson()}return e}),createStat=configure(t=>{async function e(r={}){const o=await(await t.post("repo/stat",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json();return{numObjects:BigInt(o.NumObjects),repoSize:BigInt(o.RepoSize),repoPath:o.RepoPath,version:o.Version,storageMax:BigInt(o.StorageMax)}}return e}),createVersion$1=configure(t=>{async function e(r={}){return(await(await t.post("repo/version",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json()).Version}return e});function createRepo(t){return{gc:createGc(t),stat:createStat(t),version:createVersion$1(t)}}const createBw=configure(t=>{async function*e(r={}){yield*(await t.post("stats/bw",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers,transform:o=>({totalIn:BigInt(o.TotalIn),totalOut:BigInt(o.TotalOut),rateIn:parseFloat(o.RateIn),rateOut:parseFloat(o.RateOut)})})).ndjson()}return e});function createStats(t){return{bitswap:createStat$4(t),repo:createStat(t),bw:createBw(t)}}const createAddrs=configure(t=>{async function e(r={}){const n=await t.post("swarm/addrs",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers}),{Addrs:o}=await n.json();return Object.keys(o).map(s=>({id:peerIdFromString(s),addrs:(o[s]||[]).map(a=>multiaddr$1(a))}))}return e}),createConnect=configure(t=>{async function e(r,n={}){const o=await t.post("swarm/connect",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers}),{Strings:s}=await o.json();return s||[]}return e}),createDisconnect=configure(t=>{async function e(r,n={}){const o=await t.post("swarm/disconnect",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers}),{Strings:s}=await o.json();return s||[]}return e}),createLocalAddrs=configure(t=>{async function e(r={}){const n=await t.post("swarm/addrs/local",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers}),{Strings:o}=await n.json();return(o||[]).map(s=>multiaddr$1(s))}return e}),createPeers=configure(t=>{async function e(r={}){const n=await t.post("swarm/peers",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers}),{Peers:o}=await n.json();return(o||[]).map(s=>({addr:multiaddr$1(s.Addr),peer:peerIdFromString(s.Peer),muxer:s.Muxer,latency:s.Latency,streams:s.Streams,direction:s.Direction==null?void 0:s.Direction===0?"inbound":"outbound"}))}return e});function createSwarm(t){return{addrs:createAddrs(t),connect:createConnect(t),disconnect:createDisconnect(t),localAddrs:createLocalAddrs(t),peers:createPeers(t)}}const createAddAll=configure(t=>{async function*e(r,n={}){const o=new AbortController,s=abortSignal(o.signal,n.signal),{headers:a,body:i,total:c,parts:d}=await multipartRequest(r,o,n.headers),[l,f]=typeof n.progress=="function"?createProgressHandler(c,d,n.progress):[void 0,void 0],p=await t.post("add",{searchParams:toUrlSearchParams({"stream-channels":!0,...n,progress:!!l}),onUploadProgress:f,signal:s,headers:a,body:i});for await(let v of p.ndjson())v=objectToCamel(v),v.hash!==void 0?yield toCoreInterface(v):l&&l(v.bytes||0,v.name)}return e}),createProgressHandler=(t,e,r)=>e?[void 0,createOnUploadProgress(t,e,r)]:[r,void 0],createOnUploadProgress=(t,e,r)=>{let n=0;const o=e.length;return({loaded:s,total:a})=>{const i=Math.floor(s/a*t);for(;n<o;){const{start:c,end:d,name:l}=e[n];if(i<d){r(i-c,l);break}else r(d-c,l),n+=1}}};function toCoreInterface({name:t,hash:e,size:r,mode:n,mtime:o,mtimeNsecs:s}){const a={path:t,cid:CID$2.parse(e),size:parseInt(r)};return n!=null&&(a.mode=parseInt(n,8)),o!=null&&(a.mtime={secs:o,nsecs:s||0}),a}function blobToIt(t){return typeof t.stream=="function"?browserReadableStreamToIt(t.stream()):browserReadableStreamToIt(new Response(t).body)}async function*toAsyncIterable(t){yield t}async function normaliseContent(t){if(isBytes(t))return toAsyncIterable(toBytes(t));if(typeof t=="string"||t instanceof String)return toAsyncIterable(toBytes(t.toString()));if(isBlob(t))return blobToIt(t);if(isReadableStream(t)&&(t=browserReadableStreamToIt(t)),Symbol.iterator in t||Symbol.asyncIterator in t){const e=peekableIterator(t),{value:r,done:n}=await e.peek();if(n)return toAsyncIterable(new Uint8Array(0));if(e.push(r),Number.isInteger(r))return toAsyncIterable(Uint8Array.from(await all(e)));if(isBytes(r)||typeof r=="string"||r instanceof String)return map(e,toBytes)}throw errCode$1(new Error(`Unexpected input: ${t}`),"ERR_UNEXPECTED_INPUT")}function toBytes(t){return t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer?new Uint8Array(t):Array.isArray(t)?Uint8Array.from(t):fromString$3(t.toString())}async function*normaliseCandidateSingle(t,e){if(t==null)throw errCode$1(new Error(`Unexpected input: ${t}`),"ERR_UNEXPECTED_INPUT");if(typeof t=="string"||t instanceof String){yield toFileObject(t.toString(),e);return}if(isBytes(t)||isBlob(t)){yield toFileObject(t,e);return}if(isReadableStream(t)&&(t=browserReadableStreamToIt(t)),Symbol.iterator in t||Symbol.asyncIterator in t){const r=peekableIterator(t),{value:n,done:o}=await r.peek();if(o){yield{content:[]};return}if(r.push(n),Number.isInteger(n)||isBytes(n)||typeof n=="string"||n instanceof String){yield toFileObject(r,e);return}throw errCode$1(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"),"ERR_UNEXPECTED_INPUT")}if(isFileObject(t)){yield toFileObject(t,e);return}throw errCode$1(new Error('Unexpected input: cannot convert "'+typeof t+'" into ImportCandidate'),"ERR_UNEXPECTED_INPUT")}async function toFileObject(t,e){const{path:r,mode:n,mtime:o,content:s}=t,a={path:r||"",mode:parseMode(n),mtime:parseMtime(o)};return s?a.content=await e(s):r||(a.content=await e(t)),a}function normaliseInput(t){return normaliseCandidateSingle(t,normaliseContent)}function createAdd(t){const e=createAddAll(t);return configure(()=>{async function r(n,o={}){return await last(e(normaliseInput(n),o))}return r})(t)}const createCat=configure(t=>{async function*e(r,n={}){yield*(await t.post("cat",{signal:n.signal,searchParams:toUrlSearchParams({arg:r.toString(),...n}),headers:n.headers})).iterator()}return e}),createCommands=configure(t=>async(r={})=>(await t.post("commands",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).json()),createDns=configure(t=>async(r,n={})=>(await(await t.post("dns",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers})).json()).Path),createGetEndpointConfig=configure(t=>()=>{const e=new URL(t.opts.base||"");return{host:e.hostname,port:e.port,protocol:e.protocol,pathname:e.pathname,"api-path":e.pathname}}),createGet=configure(t=>{async function*e(r,n={}){const o={arg:`${r instanceof Uint8Array?CID$2.decode(r):r}`,...n};o.compressionLevel&&(o["compression-level"]=o.compressionLevel,delete o.compressionLevel),yield*(await t.post("get",{signal:n.signal,searchParams:toUrlSearchParams(o),headers:n.headers})).iterator()}return e}),createId=configure(t=>{async function e(r={}){const o=await(await t.post("id",{signal:r.signal,searchParams:toUrlSearchParams({arg:r.peerId?r.peerId.toString():void 0,...r}),headers:r.headers})).json(),s={...objectToCamel(o)};return s.id=peerIdFromString(s.id),s.addresses&&(s.addresses=s.addresses.map(a=>multiaddr$1(a))),s}return e}),createIsOnline=t=>{const e=createId(t);async function r(n={}){const o=await e(n);return!!(o&&o.addresses&&o.addresses.length)}return r},createLs=configure((t,e)=>{async function*r(n,o={}){const s=`${n instanceof Uint8Array?CID$2.decode(n):n}`;async function a(c){let d=c.Hash;if(d.includes("/")){const f=d.startsWith("/ipfs/")?d:`/ipfs/${d}`;d=(await createStat$2(e)(f)).cid}else d=CID$2.parse(d);const l={name:c.Name,path:s+(c.Name?`/${c.Name}`:""),size:c.Size,cid:d,type:typeOf(c)};return c.Mode&&(l.mode=parseInt(c.Mode,8)),c.Mtime!==void 0&&c.Mtime!==null&&(l.mtime={secs:c.Mtime},c.MtimeNsecs!==void 0&&c.MtimeNsecs!==null&&(l.mtime.nsecs=c.MtimeNsecs)),l}const i=await t.post("ls",{signal:o.signal,searchParams:toUrlSearchParams({arg:s,...o}),headers:o.headers});for await(let c of i.ndjson()){if(c=c.Objects,!c)throw new Error("expected .Objects in results");if(c=c[0],!c)throw new Error("expected one array in results.Objects");const d=c.Links;if(!Array.isArray(d))throw new Error("expected one array in results.Objects[0].Links");if(!d.length){yield a(c);return}yield*d.map(a)}}return r});function typeOf(t){switch(t.Type){case 1:case 5:return"dir";case 2:return"file";default:return"file"}}const createMount=configure(t=>{async function e(r={}){const n=await t.post("dns",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers});return objectToCamel(await n.json())}return e}),createPing=configure(t=>{async function*e(r,n={}){yield*(await t.post("ping",{signal:n.signal,searchParams:toUrlSearchParams({arg:`${r}`,...n}),headers:n.headers,transform:objectToCamel})).ndjson()}return e}),createResolve=configure(t=>{async function e(r,n={}){const o=await t.post("resolve",{signal:n.signal,searchParams:toUrlSearchParams({arg:r,...n}),headers:n.headers}),{Path:s}=await o.json();return s}return e}),createStart=configure(t=>async(r={})=>{throw errCode$1(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")}),createStop=configure(t=>{async function e(r={}){await(await t.post("shutdown",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers})).text()}return e}),createVersion=configure(t=>{async function e(r={}){const n=await t.post("version",{signal:r.signal,searchParams:toUrlSearchParams(r),headers:r.headers});return{...objectToCamel(await n.json()),"ipfs-http-client":"1.0.0"}}return e});function create(t={}){const e={name:identity$4.name,code:identity$4.code,encode:d=>d,decode:d=>d},r=Object.values(bases$3);(t.ipld&&t.ipld.bases?t.ipld.bases:[]).forEach(d=>r.push(d));const n=new Multibases({bases:r,loadBase:t.ipld&&t.ipld.loadBase}),o=Object.values(codecs$1);[dagPB,dagCBOR,dagJSON,dagJOSE,e].concat(t.ipld&&t.ipld.codecs||[]).forEach(d=>o.push(d));const s=new Multicodecs({codecs:o,loadCodec:t.ipld&&t.ipld.loadCodec}),a=Object.values(hashes);(t.ipld&&t.ipld.hashers?t.ipld.hashers:[]).forEach(d=>a.push(d));const i=new Multihashes({hashers:a,loadHasher:t.ipld&&t.ipld.loadHasher});return{add:createAdd(t),addAll:createAddAll(t),bitswap:createBitswap(t),block:createBlock(t),bootstrap:createBootstrap(t),cat:createCat(t),commands:createCommands(t),config:createConfig(t),dag:createDag(s,t),dht:createDht(t),diag:createDiag(t),dns:createDns(t),files:createFiles(t),get:createGet(t),getEndpointConfig:createGetEndpointConfig(t),id:createId(t),isOnline:createIsOnline(t),key:createKey(t),log:createLog(t),ls:createLs(t),mount:createMount(t),name:createName(t),object:createObject(s,t),pin:createPin(t),ping:createPing(t),pubsub:createPubsub(t),refs:createRefs(t),repo:createRepo(t),resolve:createResolve(t),start:createStart(t),stats:createStats(t),stop:createStop(t),swarm:createSwarm(t),version:createVersion(t),bases:n,codecs:s,hashers:i}}const client=create({host:"ipfs.infura.io",port:5001,protocol:"https"});function EHRForm(){const[t,e]=reactExports.useState(""),[r,n]=reactExports.useState(""),[o,s]=reactExports.useState(""),[a,i]=reactExports.useState(""),[c,d]=reactExports.useState("Ready");async function l(){try{d("Encrypting EHR");const f={patientName:t,dob:r,conditions:o,medications:a,createdAt:new Date().toISOString()},p=JSON.stringify(f),v=await window.crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),u=window.crypto.getRandomValues(new Uint8Array(12)),h=new TextEncoder,S=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:u},v,h.encode(p)),y=new Uint8Array(u.length+S.byteLength);y.set(u,0),y.set(new Uint8Array(S),u.length),d("Uploading to hospital EHR");const m=btoa(String.fromCharCode(...y)),$=t||"unknown";await hospitalApi.postEHR($,{payloadBase64:m,meta:{patientName:t,dob:r}});try{d("Uploading to IPFS for proof (optional)");const w=(await client.add(y)).path,T=await crypto.subtle.digest("SHA-256",y),g=hexlify(new Uint8Array(T));if(window.ethereum){const H=await(await new BrowserProvider(window.ethereum).getSigner()).getAddress(),j=keccak256(toUtf8Bytes(H+w));await registerResource(j,w,g,JSON.stringify({patientName:t,dob:r})),d("Registered proof "+j)}else d("Hospital EHR stored (no wallet available for proof)")}catch(b){console.warn("Proof registration failed",b),d("Hospital EHR stored (proof registration skipped)")}}catch(f){console.error(f),d("Error "+(f.message||f))}}return jsxRuntimeExports.jsxs("div",{className:"p-6 bg-white rounded-2xl shadow-sm max-w-2xl mx-auto",children:[jsxRuntimeExports.jsx("h2",{className:"text-xl font-semibold mb-4",children:"Create EHR Entry"}),jsxRuntimeExports.jsx("input",{className:"border p-2 w-full mb-2",placeholder:"Patient name",value:t,onChange:f=>e(f.target.value)}),jsxRuntimeExports.jsx("input",{className:"border p-2 w-full mb-2",placeholder:"Date of birth",value:r,onChange:f=>n(f.target.value)}),jsxRuntimeExports.jsx("textarea",{className:"border p-2 w-full mb-2",placeholder:"Conditions (comma separated)",value:o,onChange:f=>s(f.target.value)}),jsxRuntimeExports.jsx("textarea",{className:"border p-2 w-full mb-2",placeholder:"Medications (comma separated)",value:a,onChange:f=>i(f.target.value)}),jsxRuntimeExports.jsxs("div",{className:"flex gap-2",children:[jsxRuntimeExports.jsx("button",{onClick:l,className:"bg-indigo-600 text-white px-4 py-2 rounded",children:"Create EHR"}),jsxRuntimeExports.jsx("div",{className:"text-sm text-slate-500 mt-2",children:c})]})]})}export{EHRForm as default};
